// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: governance.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_governance_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_governance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
#include "markets.pb.h"
#include "vega.pb.h"
#include "assets.pb.h"
#include "oracles/v1/oracle_spec.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_governance_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_governance_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_governance_2eproto;
namespace vega {
class FutureProduct;
class FutureProductDefaultTypeInternal;
extern FutureProductDefaultTypeInternal _FutureProduct_default_instance_;
class GovernanceData;
class GovernanceDataDefaultTypeInternal;
extern GovernanceDataDefaultTypeInternal _GovernanceData_default_instance_;
class GovernanceData_NoPartyEntry_DoNotUse;
class GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_NoPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_NoPartyEntry_DoNotUse_default_instance_;
class GovernanceData_YesPartyEntry_DoNotUse;
class GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal;
extern GovernanceData_YesPartyEntry_DoNotUseDefaultTypeInternal _GovernanceData_YesPartyEntry_DoNotUse_default_instance_;
class InstrumentConfiguration;
class InstrumentConfigurationDefaultTypeInternal;
extern InstrumentConfigurationDefaultTypeInternal _InstrumentConfiguration_default_instance_;
class NewAsset;
class NewAssetDefaultTypeInternal;
extern NewAssetDefaultTypeInternal _NewAsset_default_instance_;
class NewMarket;
class NewMarketDefaultTypeInternal;
extern NewMarketDefaultTypeInternal _NewMarket_default_instance_;
class NewMarketCommitment;
class NewMarketCommitmentDefaultTypeInternal;
extern NewMarketCommitmentDefaultTypeInternal _NewMarketCommitment_default_instance_;
class NewMarketConfiguration;
class NewMarketConfigurationDefaultTypeInternal;
extern NewMarketConfigurationDefaultTypeInternal _NewMarketConfiguration_default_instance_;
class Proposal;
class ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class ProposalTerms;
class ProposalTermsDefaultTypeInternal;
extern ProposalTermsDefaultTypeInternal _ProposalTerms_default_instance_;
class UpdateMarket;
class UpdateMarketDefaultTypeInternal;
extern UpdateMarketDefaultTypeInternal _UpdateMarket_default_instance_;
class UpdateNetworkParameter;
class UpdateNetworkParameterDefaultTypeInternal;
extern UpdateNetworkParameterDefaultTypeInternal _UpdateNetworkParameter_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::FutureProduct* Arena::CreateMaybeMessage<::vega::FutureProduct>(Arena*);
template<> ::vega::GovernanceData* Arena::CreateMaybeMessage<::vega::GovernanceData>(Arena*);
template<> ::vega::GovernanceData_NoPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_NoPartyEntry_DoNotUse>(Arena*);
template<> ::vega::GovernanceData_YesPartyEntry_DoNotUse* Arena::CreateMaybeMessage<::vega::GovernanceData_YesPartyEntry_DoNotUse>(Arena*);
template<> ::vega::InstrumentConfiguration* Arena::CreateMaybeMessage<::vega::InstrumentConfiguration>(Arena*);
template<> ::vega::NewAsset* Arena::CreateMaybeMessage<::vega::NewAsset>(Arena*);
template<> ::vega::NewMarket* Arena::CreateMaybeMessage<::vega::NewMarket>(Arena*);
template<> ::vega::NewMarketCommitment* Arena::CreateMaybeMessage<::vega::NewMarketCommitment>(Arena*);
template<> ::vega::NewMarketConfiguration* Arena::CreateMaybeMessage<::vega::NewMarketConfiguration>(Arena*);
template<> ::vega::Proposal* Arena::CreateMaybeMessage<::vega::Proposal>(Arena*);
template<> ::vega::ProposalTerms* Arena::CreateMaybeMessage<::vega::ProposalTerms>(Arena*);
template<> ::vega::UpdateMarket* Arena::CreateMaybeMessage<::vega::UpdateMarket>(Arena*);
template<> ::vega::UpdateNetworkParameter* Arena::CreateMaybeMessage<::vega::UpdateNetworkParameter>(Arena*);
template<> ::vega::Vote* Arena::CreateMaybeMessage<::vega::Vote>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {

enum Proposal_State : int {
  Proposal_State_STATE_UNSPECIFIED = 0,
  Proposal_State_STATE_FAILED = 1,
  Proposal_State_STATE_OPEN = 2,
  Proposal_State_STATE_PASSED = 3,
  Proposal_State_STATE_REJECTED = 4,
  Proposal_State_STATE_DECLINED = 5,
  Proposal_State_STATE_ENACTED = 6,
  Proposal_State_STATE_WAITING_FOR_NODE_VOTE = 7,
  Proposal_State_Proposal_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Proposal_State_Proposal_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Proposal_State_IsValid(int value);
constexpr Proposal_State Proposal_State_State_MIN = Proposal_State_STATE_UNSPECIFIED;
constexpr Proposal_State Proposal_State_State_MAX = Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
constexpr int Proposal_State_State_ARRAYSIZE = Proposal_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Proposal_State_descriptor();
template<typename T>
inline const std::string& Proposal_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Proposal_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Proposal_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Proposal_State_descriptor(), enum_t_value);
}
inline bool Proposal_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Proposal_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Proposal_State>(
    Proposal_State_descriptor(), name, value);
}
enum Vote_Value : int {
  Vote_Value_VALUE_UNSPECIFIED = 0,
  Vote_Value_VALUE_NO = 1,
  Vote_Value_VALUE_YES = 2,
  Vote_Value_Vote_Value_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Vote_Value_Vote_Value_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Vote_Value_IsValid(int value);
constexpr Vote_Value Vote_Value_Value_MIN = Vote_Value_VALUE_UNSPECIFIED;
constexpr Vote_Value Vote_Value_Value_MAX = Vote_Value_VALUE_YES;
constexpr int Vote_Value_Value_ARRAYSIZE = Vote_Value_Value_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Vote_Value_descriptor();
template<typename T>
inline const std::string& Vote_Value_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Vote_Value>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Vote_Value_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Vote_Value_descriptor(), enum_t_value);
}
inline bool Vote_Value_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Vote_Value* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Vote_Value>(
    Vote_Value_descriptor(), name, value);
}
enum ProposalError : int {
  PROPOSAL_ERROR_UNSPECIFIED = 0,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON = 1,
  PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE = 2,
  PROPOSAL_ERROR_ENACT_TIME_TOO_SOON = 3,
  PROPOSAL_ERROR_ENACT_TIME_TOO_LATE = 4,
  PROPOSAL_ERROR_INSUFFICIENT_TOKENS = 5,
  PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY = 6,
  PROPOSAL_ERROR_NO_PRODUCT = 7,
  PROPOSAL_ERROR_UNSUPPORTED_PRODUCT = 8,
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP = 9,
  PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED = 10,
  PROPOSAL_ERROR_NO_TRADING_MODE = 11,
  PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE = 12,
  PROPOSAL_ERROR_NODE_VALIDATION_FAILED = 13,
  PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD = 14,
  PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS = 15,
  PROPOSAL_ERROR_INVALID_ASSET = 16,
  PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS = 17,
  PROPOSAL_ERROR_NO_RISK_PARAMETERS = 18,
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_KEY = 19,
  PROPOSAL_ERROR_NETWORK_PARAMETER_INVALID_VALUE = 20,
  PROPOSAL_ERROR_NETWORK_PARAMETER_VALIDATION_FAILED = 21,
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_SMALL = 22,
  PROPOSAL_ERROR_OPENING_AUCTION_DURATION_TOO_LARGE = 23,
  PROPOSAL_ERROR_MARKET_MISSING_LIQUIDITY_COMMITMENT = 24,
  PROPOSAL_ERROR_COULD_NOT_INSTANTIATE_MARKET = 25,
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT = 26,
  PROPOSAL_ERROR_MISSING_COMMITMENT_AMOUNT = 27,
  PROPOSAL_ERROR_INVALID_FEE_AMOUNT = 28,
  PROPOSAL_ERROR_INVALID_SHAPE = 29,
  PROPOSAL_ERROR_INVALID_RISK_PARAMETER = 30,
  ProposalError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProposalError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProposalError_IsValid(int value);
constexpr ProposalError ProposalError_MIN = PROPOSAL_ERROR_UNSPECIFIED;
constexpr ProposalError ProposalError_MAX = PROPOSAL_ERROR_INVALID_RISK_PARAMETER;
constexpr int ProposalError_ARRAYSIZE = ProposalError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProposalError_descriptor();
template<typename T>
inline const std::string& ProposalError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProposalError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProposalError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProposalError_descriptor(), enum_t_value);
}
inline bool ProposalError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProposalError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProposalError>(
    ProposalError_descriptor(), name, value);
}
// ===================================================================

class FutureProduct PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.FutureProduct) */ {
 public:
  inline FutureProduct() : FutureProduct(nullptr) {}
  virtual ~FutureProduct();

  FutureProduct(const FutureProduct& from);
  FutureProduct(FutureProduct&& from) noexcept
    : FutureProduct() {
    *this = ::std::move(from);
  }

  inline FutureProduct& operator=(const FutureProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline FutureProduct& operator=(FutureProduct&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FutureProduct& default_instance();

  static inline const FutureProduct* internal_default_instance() {
    return reinterpret_cast<const FutureProduct*>(
               &_FutureProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FutureProduct& a, FutureProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(FutureProduct* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FutureProduct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FutureProduct* New() const final {
    return CreateMaybeMessage<FutureProduct>(nullptr);
  }

  FutureProduct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FutureProduct>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FutureProduct& from);
  void MergeFrom(const FutureProduct& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FutureProduct* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.FutureProduct";
  }
  protected:
  explicit FutureProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaturityFieldNumber = 1,
    kSettlementAssetFieldNumber = 2,
    kQuoteNameFieldNumber = 3,
    kOracleSpecFieldNumber = 5,
    kOracleSpecBindingFieldNumber = 6,
  };
  // string maturity = 1 [json_name = "maturity", (.validator.field) = {
  void clear_maturity();
  const std::string& maturity() const;
  void set_maturity(const std::string& value);
  void set_maturity(std::string&& value);
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  std::string* mutable_maturity();
  std::string* release_maturity();
  void set_allocated_maturity(std::string* maturity);
  private:
  const std::string& _internal_maturity() const;
  void _internal_set_maturity(const std::string& value);
  std::string* _internal_mutable_maturity();
  public:

  // string settlement_asset = 2 [json_name = "settlementAsset", (.validator.field) = {
  void clear_settlement_asset();
  const std::string& settlement_asset() const;
  void set_settlement_asset(const std::string& value);
  void set_settlement_asset(std::string&& value);
  void set_settlement_asset(const char* value);
  void set_settlement_asset(const char* value, size_t size);
  std::string* mutable_settlement_asset();
  std::string* release_settlement_asset();
  void set_allocated_settlement_asset(std::string* settlement_asset);
  private:
  const std::string& _internal_settlement_asset() const;
  void _internal_set_settlement_asset(const std::string& value);
  std::string* _internal_mutable_settlement_asset();
  public:

  // string quote_name = 3 [json_name = "quoteName", (.validator.field) = {
  void clear_quote_name();
  const std::string& quote_name() const;
  void set_quote_name(const std::string& value);
  void set_quote_name(std::string&& value);
  void set_quote_name(const char* value);
  void set_quote_name(const char* value, size_t size);
  std::string* mutable_quote_name();
  std::string* release_quote_name();
  void set_allocated_quote_name(std::string* quote_name);
  private:
  const std::string& _internal_quote_name() const;
  void _internal_set_quote_name(const std::string& value);
  std::string* _internal_mutable_quote_name();
  public:

  // .oracles.v1.OracleSpecConfiguration oracle_spec = 5 [json_name = "oracleSpec"];
  bool has_oracle_spec() const;
  private:
  bool _internal_has_oracle_spec() const;
  public:
  void clear_oracle_spec();
  const ::oracles::v1::OracleSpecConfiguration& oracle_spec() const;
  ::oracles::v1::OracleSpecConfiguration* release_oracle_spec();
  ::oracles::v1::OracleSpecConfiguration* mutable_oracle_spec();
  void set_allocated_oracle_spec(::oracles::v1::OracleSpecConfiguration* oracle_spec);
  private:
  const ::oracles::v1::OracleSpecConfiguration& _internal_oracle_spec() const;
  ::oracles::v1::OracleSpecConfiguration* _internal_mutable_oracle_spec();
  public:
  void unsafe_arena_set_allocated_oracle_spec(
      ::oracles::v1::OracleSpecConfiguration* oracle_spec);
  ::oracles::v1::OracleSpecConfiguration* unsafe_arena_release_oracle_spec();

  // .vega.OracleSpecToFutureBinding oracle_spec_binding = 6 [json_name = "oracleSpecBinding"];
  bool has_oracle_spec_binding() const;
  private:
  bool _internal_has_oracle_spec_binding() const;
  public:
  void clear_oracle_spec_binding();
  const ::vega::OracleSpecToFutureBinding& oracle_spec_binding() const;
  ::vega::OracleSpecToFutureBinding* release_oracle_spec_binding();
  ::vega::OracleSpecToFutureBinding* mutable_oracle_spec_binding();
  void set_allocated_oracle_spec_binding(::vega::OracleSpecToFutureBinding* oracle_spec_binding);
  private:
  const ::vega::OracleSpecToFutureBinding& _internal_oracle_spec_binding() const;
  ::vega::OracleSpecToFutureBinding* _internal_mutable_oracle_spec_binding();
  public:
  void unsafe_arena_set_allocated_oracle_spec_binding(
      ::vega::OracleSpecToFutureBinding* oracle_spec_binding);
  ::vega::OracleSpecToFutureBinding* unsafe_arena_release_oracle_spec_binding();

  // @@protoc_insertion_point(class_scope:vega.FutureProduct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maturity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_asset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_name_;
  ::oracles::v1::OracleSpecConfiguration* oracle_spec_;
  ::vega::OracleSpecToFutureBinding* oracle_spec_binding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class InstrumentConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentConfiguration) */ {
 public:
  inline InstrumentConfiguration() : InstrumentConfiguration(nullptr) {}
  virtual ~InstrumentConfiguration();

  InstrumentConfiguration(const InstrumentConfiguration& from);
  InstrumentConfiguration(InstrumentConfiguration&& from) noexcept
    : InstrumentConfiguration() {
    *this = ::std::move(from);
  }

  inline InstrumentConfiguration& operator=(const InstrumentConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentConfiguration& operator=(InstrumentConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentConfiguration& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static inline const InstrumentConfiguration* internal_default_instance() {
    return reinterpret_cast<const InstrumentConfiguration*>(
               &_InstrumentConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InstrumentConfiguration& a, InstrumentConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentConfiguration* New() const final {
    return CreateMaybeMessage<InstrumentConfiguration>(nullptr);
  }

  InstrumentConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentConfiguration& from);
  void MergeFrom(const InstrumentConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.InstrumentConfiguration";
  }
  protected:
  explicit InstrumentConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCodeFieldNumber = 2,
    kFutureFieldNumber = 100,
  };
  // string name = 1 [json_name = "name", (.validator.field) = {
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string code = 2 [json_name = "code", (.validator.field) = {
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .vega.FutureProduct future = 100 [json_name = "future"];
  bool has_future() const;
  private:
  bool _internal_has_future() const;
  public:
  void clear_future();
  const ::vega::FutureProduct& future() const;
  ::vega::FutureProduct* release_future();
  ::vega::FutureProduct* mutable_future();
  void set_allocated_future(::vega::FutureProduct* future);
  private:
  const ::vega::FutureProduct& _internal_future() const;
  ::vega::FutureProduct* _internal_mutable_future();
  public:
  void unsafe_arena_set_allocated_future(
      ::vega::FutureProduct* future);
  ::vega::FutureProduct* unsafe_arena_release_future();

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.InstrumentConfiguration)
 private:
  class _Internal;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::FutureProduct* future_;
  } product_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarketConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarketConfiguration) */ {
 public:
  inline NewMarketConfiguration() : NewMarketConfiguration(nullptr) {}
  virtual ~NewMarketConfiguration();

  NewMarketConfiguration(const NewMarketConfiguration& from);
  NewMarketConfiguration(NewMarketConfiguration&& from) noexcept
    : NewMarketConfiguration() {
    *this = ::std::move(from);
  }

  inline NewMarketConfiguration& operator=(const NewMarketConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarketConfiguration& operator=(NewMarketConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarketConfiguration& default_instance();

  enum RiskParametersCase {
    kSimple = 100,
    kLogNormal = 101,
    RISK_PARAMETERS_NOT_SET = 0,
  };

  enum TradingModeCase {
    kContinuous = 200,
    kDiscrete = 201,
    TRADING_MODE_NOT_SET = 0,
  };

  static inline const NewMarketConfiguration* internal_default_instance() {
    return reinterpret_cast<const NewMarketConfiguration*>(
               &_NewMarketConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewMarketConfiguration& a, NewMarketConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarketConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarketConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarketConfiguration* New() const final {
    return CreateMaybeMessage<NewMarketConfiguration>(nullptr);
  }

  NewMarketConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarketConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarketConfiguration& from);
  void MergeFrom(const NewMarketConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarketConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarketConfiguration";
  }
  protected:
  explicit NewMarketConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kInstrumentFieldNumber = 1,
    kPriceMonitoringParametersFieldNumber = 4,
    kLiquidityMonitoringParametersFieldNumber = 5,
    kDecimalPlacesFieldNumber = 2,
    kSimpleFieldNumber = 100,
    kLogNormalFieldNumber = 101,
    kContinuousFieldNumber = 200,
    kDiscreteFieldNumber = 201,
  };
  // repeated string metadata = 3 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  const std::string& metadata(int index) const;
  std::string* mutable_metadata(int index);
  void set_metadata(int index, const std::string& value);
  void set_metadata(int index, std::string&& value);
  void set_metadata(int index, const char* value);
  void set_metadata(int index, const char* value, size_t size);
  std::string* add_metadata();
  void add_metadata(const std::string& value);
  void add_metadata(std::string&& value);
  void add_metadata(const char* value);
  void add_metadata(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_metadata();
  private:
  const std::string& _internal_metadata(int index) const;
  std::string* _internal_add_metadata();
  public:

  // .vega.InstrumentConfiguration instrument = 1 [json_name = "instrument", (.validator.field) = {
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::vega::InstrumentConfiguration& instrument() const;
  ::vega::InstrumentConfiguration* release_instrument();
  ::vega::InstrumentConfiguration* mutable_instrument();
  void set_allocated_instrument(::vega::InstrumentConfiguration* instrument);
  private:
  const ::vega::InstrumentConfiguration& _internal_instrument() const;
  ::vega::InstrumentConfiguration* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::vega::InstrumentConfiguration* instrument);
  ::vega::InstrumentConfiguration* unsafe_arena_release_instrument();

  // .vega.PriceMonitoringParameters price_monitoring_parameters = 4 [json_name = "priceMonitoringParameters"];
  bool has_price_monitoring_parameters() const;
  private:
  bool _internal_has_price_monitoring_parameters() const;
  public:
  void clear_price_monitoring_parameters();
  const ::vega::PriceMonitoringParameters& price_monitoring_parameters() const;
  ::vega::PriceMonitoringParameters* release_price_monitoring_parameters();
  ::vega::PriceMonitoringParameters* mutable_price_monitoring_parameters();
  void set_allocated_price_monitoring_parameters(::vega::PriceMonitoringParameters* price_monitoring_parameters);
  private:
  const ::vega::PriceMonitoringParameters& _internal_price_monitoring_parameters() const;
  ::vega::PriceMonitoringParameters* _internal_mutable_price_monitoring_parameters();
  public:
  void unsafe_arena_set_allocated_price_monitoring_parameters(
      ::vega::PriceMonitoringParameters* price_monitoring_parameters);
  ::vega::PriceMonitoringParameters* unsafe_arena_release_price_monitoring_parameters();

  // .vega.LiquidityMonitoringParameters liquidity_monitoring_parameters = 5 [json_name = "liquidityMonitoringParameters"];
  bool has_liquidity_monitoring_parameters() const;
  private:
  bool _internal_has_liquidity_monitoring_parameters() const;
  public:
  void clear_liquidity_monitoring_parameters();
  const ::vega::LiquidityMonitoringParameters& liquidity_monitoring_parameters() const;
  ::vega::LiquidityMonitoringParameters* release_liquidity_monitoring_parameters();
  ::vega::LiquidityMonitoringParameters* mutable_liquidity_monitoring_parameters();
  void set_allocated_liquidity_monitoring_parameters(::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters);
  private:
  const ::vega::LiquidityMonitoringParameters& _internal_liquidity_monitoring_parameters() const;
  ::vega::LiquidityMonitoringParameters* _internal_mutable_liquidity_monitoring_parameters();
  public:
  void unsafe_arena_set_allocated_liquidity_monitoring_parameters(
      ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters);
  ::vega::LiquidityMonitoringParameters* unsafe_arena_release_liquidity_monitoring_parameters();

  // uint64 decimal_places = 2 [json_name = "decimalPlaces", (.validator.field) = {
  void clear_decimal_places();
  ::PROTOBUF_NAMESPACE_ID::uint64 decimal_places() const;
  void set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_decimal_places() const;
  void _internal_set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.SimpleModelParams simple = 100 [json_name = "simple"];
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;
  public:
  void clear_simple();
  const ::vega::SimpleModelParams& simple() const;
  ::vega::SimpleModelParams* release_simple();
  ::vega::SimpleModelParams* mutable_simple();
  void set_allocated_simple(::vega::SimpleModelParams* simple);
  private:
  const ::vega::SimpleModelParams& _internal_simple() const;
  ::vega::SimpleModelParams* _internal_mutable_simple();
  public:
  void unsafe_arena_set_allocated_simple(
      ::vega::SimpleModelParams* simple);
  ::vega::SimpleModelParams* unsafe_arena_release_simple();

  // .vega.LogNormalRiskModel log_normal = 101 [json_name = "logNormal"];
  bool has_log_normal() const;
  private:
  bool _internal_has_log_normal() const;
  public:
  void clear_log_normal();
  const ::vega::LogNormalRiskModel& log_normal() const;
  ::vega::LogNormalRiskModel* release_log_normal();
  ::vega::LogNormalRiskModel* mutable_log_normal();
  void set_allocated_log_normal(::vega::LogNormalRiskModel* log_normal);
  private:
  const ::vega::LogNormalRiskModel& _internal_log_normal() const;
  ::vega::LogNormalRiskModel* _internal_mutable_log_normal();
  public:
  void unsafe_arena_set_allocated_log_normal(
      ::vega::LogNormalRiskModel* log_normal);
  ::vega::LogNormalRiskModel* unsafe_arena_release_log_normal();

  // .vega.ContinuousTrading continuous = 200 [json_name = "continuous"];
  bool has_continuous() const;
  private:
  bool _internal_has_continuous() const;
  public:
  void clear_continuous();
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);
  private:
  const ::vega::ContinuousTrading& _internal_continuous() const;
  ::vega::ContinuousTrading* _internal_mutable_continuous();
  public:
  void unsafe_arena_set_allocated_continuous(
      ::vega::ContinuousTrading* continuous);
  ::vega::ContinuousTrading* unsafe_arena_release_continuous();

  // .vega.DiscreteTrading discrete = 201 [json_name = "discrete"];
  bool has_discrete() const;
  private:
  bool _internal_has_discrete() const;
  public:
  void clear_discrete();
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);
  private:
  const ::vega::DiscreteTrading& _internal_discrete() const;
  ::vega::DiscreteTrading* _internal_mutable_discrete();
  public:
  void unsafe_arena_set_allocated_discrete(
      ::vega::DiscreteTrading* discrete);
  ::vega::DiscreteTrading* unsafe_arena_release_discrete();

  void clear_risk_parameters();
  RiskParametersCase risk_parameters_case() const;
  void clear_trading_mode();
  TradingModeCase trading_mode_case() const;
  // @@protoc_insertion_point(class_scope:vega.NewMarketConfiguration)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_log_normal();
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_risk_parameters() const;
  inline void clear_has_risk_parameters();

  inline bool has_trading_mode() const;
  inline void clear_has_trading_mode();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> metadata_;
  ::vega::InstrumentConfiguration* instrument_;
  ::vega::PriceMonitoringParameters* price_monitoring_parameters_;
  ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters_;
  ::PROTOBUF_NAMESPACE_ID::uint64 decimal_places_;
  union RiskParametersUnion {
    RiskParametersUnion() {}
    ::vega::SimpleModelParams* simple_;
    ::vega::LogNormalRiskModel* log_normal_;
  } risk_parameters_;
  union TradingModeUnion {
    TradingModeUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } trading_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[2];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarketCommitment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarketCommitment) */ {
 public:
  inline NewMarketCommitment() : NewMarketCommitment(nullptr) {}
  virtual ~NewMarketCommitment();

  NewMarketCommitment(const NewMarketCommitment& from);
  NewMarketCommitment(NewMarketCommitment&& from) noexcept
    : NewMarketCommitment() {
    *this = ::std::move(from);
  }

  inline NewMarketCommitment& operator=(const NewMarketCommitment& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarketCommitment& operator=(NewMarketCommitment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarketCommitment& default_instance();

  static inline const NewMarketCommitment* internal_default_instance() {
    return reinterpret_cast<const NewMarketCommitment*>(
               &_NewMarketCommitment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewMarketCommitment& a, NewMarketCommitment& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarketCommitment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarketCommitment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarketCommitment* New() const final {
    return CreateMaybeMessage<NewMarketCommitment>(nullptr);
  }

  NewMarketCommitment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarketCommitment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarketCommitment& from);
  void MergeFrom(const NewMarketCommitment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarketCommitment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarketCommitment";
  }
  protected:
  explicit NewMarketCommitment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellsFieldNumber = 3,
    kBuysFieldNumber = 4,
    kFeeFieldNumber = 2,
    kReferenceFieldNumber = 5,
    kCommitmentAmountFieldNumber = 1,
  };
  // repeated .vega.LiquidityOrder sells = 3 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;
  public:
  void clear_sells();
  ::vega::LiquidityOrder* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
      mutable_sells();
  private:
  const ::vega::LiquidityOrder& _internal_sells(int index) const;
  ::vega::LiquidityOrder* _internal_add_sells();
  public:
  const ::vega::LiquidityOrder& sells(int index) const;
  ::vega::LiquidityOrder* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
      sells() const;

  // repeated .vega.LiquidityOrder buys = 4 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;
  public:
  void clear_buys();
  ::vega::LiquidityOrder* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
      mutable_buys();
  private:
  const ::vega::LiquidityOrder& _internal_buys(int index) const;
  ::vega::LiquidityOrder* _internal_add_buys();
  public:
  const ::vega::LiquidityOrder& buys(int index) const;
  ::vega::LiquidityOrder* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
      buys() const;

  // string fee = 2 [json_name = "fee"];
  void clear_fee();
  const std::string& fee() const;
  void set_fee(const std::string& value);
  void set_fee(std::string&& value);
  void set_fee(const char* value);
  void set_fee(const char* value, size_t size);
  std::string* mutable_fee();
  std::string* release_fee();
  void set_allocated_fee(std::string* fee);
  private:
  const std::string& _internal_fee() const;
  void _internal_set_fee(const std::string& value);
  std::string* _internal_mutable_fee();
  public:

  // string reference = 5 [json_name = "reference"];
  void clear_reference();
  const std::string& reference() const;
  void set_reference(const std::string& value);
  void set_reference(std::string&& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  std::string* mutable_reference();
  std::string* release_reference();
  void set_allocated_reference(std::string* reference);
  private:
  const std::string& _internal_reference() const;
  void _internal_set_reference(const std::string& value);
  std::string* _internal_mutable_reference();
  public:

  // uint64 commitment_amount = 1 [json_name = "commitmentAmount"];
  void clear_commitment_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 commitment_amount() const;
  void set_commitment_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_commitment_amount() const;
  void _internal_set_commitment_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.NewMarketCommitment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder > sells_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder > buys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_;
  ::PROTOBUF_NAMESPACE_ID::uint64 commitment_amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewMarket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewMarket) */ {
 public:
  inline NewMarket() : NewMarket(nullptr) {}
  virtual ~NewMarket();

  NewMarket(const NewMarket& from);
  NewMarket(NewMarket&& from) noexcept
    : NewMarket() {
    *this = ::std::move(from);
  }

  inline NewMarket& operator=(const NewMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMarket& operator=(NewMarket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewMarket& default_instance();

  static inline const NewMarket* internal_default_instance() {
    return reinterpret_cast<const NewMarket*>(
               &_NewMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewMarket& a, NewMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMarket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMarket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewMarket* New() const final {
    return CreateMaybeMessage<NewMarket>(nullptr);
  }

  NewMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewMarket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewMarket& from);
  void MergeFrom(const NewMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMarket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewMarket";
  }
  protected:
  explicit NewMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
    kLiquidityCommitmentFieldNumber = 2,
  };
  // .vega.NewMarketConfiguration changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::NewMarketConfiguration& changes() const;
  ::vega::NewMarketConfiguration* release_changes();
  ::vega::NewMarketConfiguration* mutable_changes();
  void set_allocated_changes(::vega::NewMarketConfiguration* changes);
  private:
  const ::vega::NewMarketConfiguration& _internal_changes() const;
  ::vega::NewMarketConfiguration* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::NewMarketConfiguration* changes);
  ::vega::NewMarketConfiguration* unsafe_arena_release_changes();

  // .vega.NewMarketCommitment liquidity_commitment = 2 [json_name = "liquidityCommitment"];
  bool has_liquidity_commitment() const;
  private:
  bool _internal_has_liquidity_commitment() const;
  public:
  void clear_liquidity_commitment();
  const ::vega::NewMarketCommitment& liquidity_commitment() const;
  ::vega::NewMarketCommitment* release_liquidity_commitment();
  ::vega::NewMarketCommitment* mutable_liquidity_commitment();
  void set_allocated_liquidity_commitment(::vega::NewMarketCommitment* liquidity_commitment);
  private:
  const ::vega::NewMarketCommitment& _internal_liquidity_commitment() const;
  ::vega::NewMarketCommitment* _internal_mutable_liquidity_commitment();
  public:
  void unsafe_arena_set_allocated_liquidity_commitment(
      ::vega::NewMarketCommitment* liquidity_commitment);
  ::vega::NewMarketCommitment* unsafe_arena_release_liquidity_commitment();

  // @@protoc_insertion_point(class_scope:vega.NewMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::NewMarketConfiguration* changes_;
  ::vega::NewMarketCommitment* liquidity_commitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class UpdateMarket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.UpdateMarket) */ {
 public:
  inline UpdateMarket() : UpdateMarket(nullptr) {}
  virtual ~UpdateMarket();

  UpdateMarket(const UpdateMarket& from);
  UpdateMarket(UpdateMarket&& from) noexcept
    : UpdateMarket() {
    *this = ::std::move(from);
  }

  inline UpdateMarket& operator=(const UpdateMarket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMarket& operator=(UpdateMarket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateMarket& default_instance();

  static inline const UpdateMarket* internal_default_instance() {
    return reinterpret_cast<const UpdateMarket*>(
               &_UpdateMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateMarket& a, UpdateMarket& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMarket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMarket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateMarket* New() const final {
    return CreateMaybeMessage<UpdateMarket>(nullptr);
  }

  UpdateMarket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateMarket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateMarket& from);
  void MergeFrom(const UpdateMarket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMarket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.UpdateMarket";
  }
  protected:
  explicit UpdateMarket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vega.UpdateMarket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetworkParameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.UpdateNetworkParameter) */ {
 public:
  inline UpdateNetworkParameter() : UpdateNetworkParameter(nullptr) {}
  virtual ~UpdateNetworkParameter();

  UpdateNetworkParameter(const UpdateNetworkParameter& from);
  UpdateNetworkParameter(UpdateNetworkParameter&& from) noexcept
    : UpdateNetworkParameter() {
    *this = ::std::move(from);
  }

  inline UpdateNetworkParameter& operator=(const UpdateNetworkParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNetworkParameter& operator=(UpdateNetworkParameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateNetworkParameter& default_instance();

  static inline const UpdateNetworkParameter* internal_default_instance() {
    return reinterpret_cast<const UpdateNetworkParameter*>(
               &_UpdateNetworkParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateNetworkParameter& a, UpdateNetworkParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNetworkParameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNetworkParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNetworkParameter* New() const final {
    return CreateMaybeMessage<UpdateNetworkParameter>(nullptr);
  }

  UpdateNetworkParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNetworkParameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateNetworkParameter& from);
  void MergeFrom(const UpdateNetworkParameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetworkParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.UpdateNetworkParameter";
  }
  protected:
  explicit UpdateNetworkParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
  };
  // .vega.NetworkParameter changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::NetworkParameter& changes() const;
  ::vega::NetworkParameter* release_changes();
  ::vega::NetworkParameter* mutable_changes();
  void set_allocated_changes(::vega::NetworkParameter* changes);
  private:
  const ::vega::NetworkParameter& _internal_changes() const;
  ::vega::NetworkParameter* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::NetworkParameter* changes);
  ::vega::NetworkParameter* unsafe_arena_release_changes();

  // @@protoc_insertion_point(class_scope:vega.UpdateNetworkParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::NetworkParameter* changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class NewAsset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.NewAsset) */ {
 public:
  inline NewAsset() : NewAsset(nullptr) {}
  virtual ~NewAsset();

  NewAsset(const NewAsset& from);
  NewAsset(NewAsset&& from) noexcept
    : NewAsset() {
    *this = ::std::move(from);
  }

  inline NewAsset& operator=(const NewAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAsset& operator=(NewAsset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewAsset& default_instance();

  static inline const NewAsset* internal_default_instance() {
    return reinterpret_cast<const NewAsset*>(
               &_NewAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NewAsset& a, NewAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAsset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewAsset* New() const final {
    return CreateMaybeMessage<NewAsset>(nullptr);
  }

  NewAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewAsset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewAsset& from);
  void MergeFrom(const NewAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.NewAsset";
  }
  protected:
  explicit NewAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
  };
  // .vega.AssetSource changes = 1 [json_name = "changes", (.validator.field) = {
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::vega::AssetSource& changes() const;
  ::vega::AssetSource* release_changes();
  ::vega::AssetSource* mutable_changes();
  void set_allocated_changes(::vega::AssetSource* changes);
  private:
  const ::vega::AssetSource& _internal_changes() const;
  ::vega::AssetSource* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::vega::AssetSource* changes);
  ::vega::AssetSource* unsafe_arena_release_changes();

  // @@protoc_insertion_point(class_scope:vega.NewAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::AssetSource* changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class ProposalTerms PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ProposalTerms) */ {
 public:
  inline ProposalTerms() : ProposalTerms(nullptr) {}
  virtual ~ProposalTerms();

  ProposalTerms(const ProposalTerms& from);
  ProposalTerms(ProposalTerms&& from) noexcept
    : ProposalTerms() {
    *this = ::std::move(from);
  }

  inline ProposalTerms& operator=(const ProposalTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalTerms& operator=(ProposalTerms&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposalTerms& default_instance();

  enum ChangeCase {
    kUpdateMarket = 101,
    kNewMarket = 102,
    kUpdateNetworkParameter = 103,
    kNewAsset = 104,
    CHANGE_NOT_SET = 0,
  };

  static inline const ProposalTerms* internal_default_instance() {
    return reinterpret_cast<const ProposalTerms*>(
               &_ProposalTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProposalTerms& a, ProposalTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalTerms* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalTerms* New() const final {
    return CreateMaybeMessage<ProposalTerms>(nullptr);
  }

  ProposalTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalTerms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposalTerms& from);
  void MergeFrom(const ProposalTerms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalTerms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ProposalTerms";
  }
  protected:
  explicit ProposalTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosingTimestampFieldNumber = 1,
    kEnactmentTimestampFieldNumber = 2,
    kValidationTimestampFieldNumber = 3,
    kUpdateMarketFieldNumber = 101,
    kNewMarketFieldNumber = 102,
    kUpdateNetworkParameterFieldNumber = 103,
    kNewAssetFieldNumber = 104,
  };
  // int64 closing_timestamp = 1 [json_name = "closingTimestamp", (.validator.field) = {
  void clear_closing_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 closing_timestamp() const;
  void set_closing_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_closing_timestamp() const;
  void _internal_set_closing_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 enactment_timestamp = 2 [json_name = "enactmentTimestamp", (.validator.field) = {
  void clear_enactment_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 enactment_timestamp() const;
  void set_enactment_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_enactment_timestamp() const;
  void _internal_set_enactment_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 validation_timestamp = 3 [json_name = "validationTimestamp"];
  void clear_validation_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 validation_timestamp() const;
  void set_validation_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_validation_timestamp() const;
  void _internal_set_validation_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vega.UpdateMarket update_market = 101 [json_name = "updateMarket"];
  bool has_update_market() const;
  private:
  bool _internal_has_update_market() const;
  public:
  void clear_update_market();
  const ::vega::UpdateMarket& update_market() const;
  ::vega::UpdateMarket* release_update_market();
  ::vega::UpdateMarket* mutable_update_market();
  void set_allocated_update_market(::vega::UpdateMarket* update_market);
  private:
  const ::vega::UpdateMarket& _internal_update_market() const;
  ::vega::UpdateMarket* _internal_mutable_update_market();
  public:
  void unsafe_arena_set_allocated_update_market(
      ::vega::UpdateMarket* update_market);
  ::vega::UpdateMarket* unsafe_arena_release_update_market();

  // .vega.NewMarket new_market = 102 [json_name = "newMarket"];
  bool has_new_market() const;
  private:
  bool _internal_has_new_market() const;
  public:
  void clear_new_market();
  const ::vega::NewMarket& new_market() const;
  ::vega::NewMarket* release_new_market();
  ::vega::NewMarket* mutable_new_market();
  void set_allocated_new_market(::vega::NewMarket* new_market);
  private:
  const ::vega::NewMarket& _internal_new_market() const;
  ::vega::NewMarket* _internal_mutable_new_market();
  public:
  void unsafe_arena_set_allocated_new_market(
      ::vega::NewMarket* new_market);
  ::vega::NewMarket* unsafe_arena_release_new_market();

  // .vega.UpdateNetworkParameter update_network_parameter = 103 [json_name = "updateNetworkParameter"];
  bool has_update_network_parameter() const;
  private:
  bool _internal_has_update_network_parameter() const;
  public:
  void clear_update_network_parameter();
  const ::vega::UpdateNetworkParameter& update_network_parameter() const;
  ::vega::UpdateNetworkParameter* release_update_network_parameter();
  ::vega::UpdateNetworkParameter* mutable_update_network_parameter();
  void set_allocated_update_network_parameter(::vega::UpdateNetworkParameter* update_network_parameter);
  private:
  const ::vega::UpdateNetworkParameter& _internal_update_network_parameter() const;
  ::vega::UpdateNetworkParameter* _internal_mutable_update_network_parameter();
  public:
  void unsafe_arena_set_allocated_update_network_parameter(
      ::vega::UpdateNetworkParameter* update_network_parameter);
  ::vega::UpdateNetworkParameter* unsafe_arena_release_update_network_parameter();

  // .vega.NewAsset new_asset = 104 [json_name = "newAsset"];
  bool has_new_asset() const;
  private:
  bool _internal_has_new_asset() const;
  public:
  void clear_new_asset();
  const ::vega::NewAsset& new_asset() const;
  ::vega::NewAsset* release_new_asset();
  ::vega::NewAsset* mutable_new_asset();
  void set_allocated_new_asset(::vega::NewAsset* new_asset);
  private:
  const ::vega::NewAsset& _internal_new_asset() const;
  ::vega::NewAsset* _internal_mutable_new_asset();
  public:
  void unsafe_arena_set_allocated_new_asset(
      ::vega::NewAsset* new_asset);
  ::vega::NewAsset* unsafe_arena_release_new_asset();

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:vega.ProposalTerms)
 private:
  class _Internal;
  void set_has_update_market();
  void set_has_new_market();
  void set_has_update_network_parameter();
  void set_has_new_asset();

  inline bool has_change() const;
  inline void clear_has_change();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 closing_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 enactment_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 validation_timestamp_;
  union ChangeUnion {
    ChangeUnion() {}
    ::vega::UpdateMarket* update_market_;
    ::vega::NewMarket* new_market_;
    ::vega::UpdateNetworkParameter* update_network_parameter_;
    ::vega::NewAsset* new_asset_;
  } change_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class GovernanceData_YesPartyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_YesPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GovernanceData_YesPartyEntry_DoNotUse();
  explicit GovernanceData_YesPartyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GovernanceData_YesPartyEntry_DoNotUse& other);
  static const GovernanceData_YesPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_YesPartyEntry_DoNotUse*>(&_GovernanceData_YesPartyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vega.GovernanceData.YesPartyEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class GovernanceData_NoPartyEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GovernanceData_NoPartyEntry_DoNotUse,
    std::string, ::vega::Vote,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GovernanceData_NoPartyEntry_DoNotUse();
  explicit GovernanceData_NoPartyEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GovernanceData_NoPartyEntry_DoNotUse& other);
  static const GovernanceData_NoPartyEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GovernanceData_NoPartyEntry_DoNotUse*>(&_GovernanceData_NoPartyEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "vega.GovernanceData.NoPartyEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[10];
  }

  public:
};

// -------------------------------------------------------------------

class GovernanceData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.GovernanceData) */ {
 public:
  inline GovernanceData() : GovernanceData(nullptr) {}
  virtual ~GovernanceData();

  GovernanceData(const GovernanceData& from);
  GovernanceData(GovernanceData&& from) noexcept
    : GovernanceData() {
    *this = ::std::move(from);
  }

  inline GovernanceData& operator=(const GovernanceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GovernanceData& operator=(GovernanceData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GovernanceData& default_instance();

  static inline const GovernanceData* internal_default_instance() {
    return reinterpret_cast<const GovernanceData*>(
               &_GovernanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GovernanceData& a, GovernanceData& b) {
    a.Swap(&b);
  }
  inline void Swap(GovernanceData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GovernanceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GovernanceData* New() const final {
    return CreateMaybeMessage<GovernanceData>(nullptr);
  }

  GovernanceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GovernanceData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GovernanceData& from);
  void MergeFrom(const GovernanceData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GovernanceData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.GovernanceData";
  }
  protected:
  explicit GovernanceData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kYesFieldNumber = 2,
    kNoFieldNumber = 3,
    kYesPartyFieldNumber = 4,
    kNoPartyFieldNumber = 5,
    kProposalFieldNumber = 1,
  };
  // repeated .vega.Vote yes = 2 [json_name = "yes"];
  int yes_size() const;
  private:
  int _internal_yes_size() const;
  public:
  void clear_yes();
  ::vega::Vote* mutable_yes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
      mutable_yes();
  private:
  const ::vega::Vote& _internal_yes(int index) const;
  ::vega::Vote* _internal_add_yes();
  public:
  const ::vega::Vote& yes(int index) const;
  ::vega::Vote* add_yes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
      yes() const;

  // repeated .vega.Vote no = 3 [json_name = "no"];
  int no_size() const;
  private:
  int _internal_no_size() const;
  public:
  void clear_no();
  ::vega::Vote* mutable_no(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
      mutable_no();
  private:
  const ::vega::Vote& _internal_no(int index) const;
  ::vega::Vote* _internal_add_no();
  public:
  const ::vega::Vote& no(int index) const;
  ::vega::Vote* add_no();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
      no() const;

  // map<string, .vega.Vote> yes_party = 4 [json_name = "yesParty"];
  int yes_party_size() const;
  private:
  int _internal_yes_party_size() const;
  public:
  void clear_yes_party();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      _internal_yes_party() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      _internal_mutable_yes_party();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      yes_party() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      mutable_yes_party();

  // map<string, .vega.Vote> no_party = 5 [json_name = "noParty"];
  int no_party_size() const;
  private:
  int _internal_no_party_size() const;
  public:
  void clear_no_party();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      _internal_no_party() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      _internal_mutable_no_party();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
      no_party() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
      mutable_no_party();

  // .vega.Proposal proposal = 1 [json_name = "proposal"];
  bool has_proposal() const;
  private:
  bool _internal_has_proposal() const;
  public:
  void clear_proposal();
  const ::vega::Proposal& proposal() const;
  ::vega::Proposal* release_proposal();
  ::vega::Proposal* mutable_proposal();
  void set_allocated_proposal(::vega::Proposal* proposal);
  private:
  const ::vega::Proposal& _internal_proposal() const;
  ::vega::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::vega::Proposal* proposal);
  ::vega::Proposal* unsafe_arena_release_proposal();

  // @@protoc_insertion_point(class_scope:vega.GovernanceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote > yes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote > no_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GovernanceData_YesPartyEntry_DoNotUse,
      std::string, ::vega::Vote,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> yes_party_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GovernanceData_NoPartyEntry_DoNotUse,
      std::string, ::vega::Vote,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> no_party_;
  ::vega::Proposal* proposal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class Proposal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Proposal) */ {
 public:
  inline Proposal() : Proposal(nullptr) {}
  virtual ~Proposal();

  Proposal(const Proposal& from);
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposal& operator=(Proposal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Proposal& default_instance();

  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Proposal* New() const final {
    return CreateMaybeMessage<Proposal>(nullptr);
  }

  Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Proposal& from);
  void MergeFrom(const Proposal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Proposal";
  }
  protected:
  explicit Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Proposal_State State;
  static constexpr State STATE_UNSPECIFIED =
    Proposal_State_STATE_UNSPECIFIED;
  static constexpr State STATE_FAILED =
    Proposal_State_STATE_FAILED;
  static constexpr State STATE_OPEN =
    Proposal_State_STATE_OPEN;
  static constexpr State STATE_PASSED =
    Proposal_State_STATE_PASSED;
  static constexpr State STATE_REJECTED =
    Proposal_State_STATE_REJECTED;
  static constexpr State STATE_DECLINED =
    Proposal_State_STATE_DECLINED;
  static constexpr State STATE_ENACTED =
    Proposal_State_STATE_ENACTED;
  static constexpr State STATE_WAITING_FOR_NODE_VOTE =
    Proposal_State_STATE_WAITING_FOR_NODE_VOTE;
  static inline bool State_IsValid(int value) {
    return Proposal_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Proposal_State_State_MIN;
  static constexpr State State_MAX =
    Proposal_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Proposal_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Proposal_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Proposal_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Proposal_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kReferenceFieldNumber = 2,
    kPartyIdFieldNumber = 3,
    kTermsFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kStateFieldNumber = 4,
    kReasonFieldNumber = 7,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string reference = 2 [json_name = "reference"];
  void clear_reference();
  const std::string& reference() const;
  void set_reference(const std::string& value);
  void set_reference(std::string&& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  std::string* mutable_reference();
  std::string* release_reference();
  void set_allocated_reference(std::string* reference);
  private:
  const std::string& _internal_reference() const;
  void _internal_set_reference(const std::string& value);
  std::string* _internal_mutable_reference();
  public:

  // string party_id = 3 [json_name = "partyId", (.validator.field) = {
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // .vega.ProposalTerms terms = 6 [json_name = "terms", (.validator.field) = {
  bool has_terms() const;
  private:
  bool _internal_has_terms() const;
  public:
  void clear_terms();
  const ::vega::ProposalTerms& terms() const;
  ::vega::ProposalTerms* release_terms();
  ::vega::ProposalTerms* mutable_terms();
  void set_allocated_terms(::vega::ProposalTerms* terms);
  private:
  const ::vega::ProposalTerms& _internal_terms() const;
  ::vega::ProposalTerms* _internal_mutable_terms();
  public:
  void unsafe_arena_set_allocated_terms(
      ::vega::ProposalTerms* terms);
  ::vega::ProposalTerms* unsafe_arena_release_terms();

  // int64 timestamp = 5 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .vega.Proposal.State state = 4 [json_name = "state", (.validator.field) = {
  void clear_state();
  ::vega::Proposal_State state() const;
  void set_state(::vega::Proposal_State value);
  private:
  ::vega::Proposal_State _internal_state() const;
  void _internal_set_state(::vega::Proposal_State value);
  public:

  // .vega.ProposalError reason = 7 [json_name = "reason"];
  void clear_reason();
  ::vega::ProposalError reason() const;
  void set_reason(::vega::ProposalError value);
  private:
  ::vega::ProposalError _internal_reason() const;
  void _internal_set_reason(::vega::ProposalError value);
  public:

  // @@protoc_insertion_point(class_scope:vega.Proposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::vega::ProposalTerms* terms_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int state_;
  int reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// -------------------------------------------------------------------

class Vote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {}
  virtual ~Vote();

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vote& default_instance();

  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_governance_2eproto);
    return ::descriptor_table_governance_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Vote_Value Value;
  static constexpr Value VALUE_UNSPECIFIED =
    Vote_Value_VALUE_UNSPECIFIED;
  static constexpr Value VALUE_NO =
    Vote_Value_VALUE_NO;
  static constexpr Value VALUE_YES =
    Vote_Value_VALUE_YES;
  static inline bool Value_IsValid(int value) {
    return Vote_Value_IsValid(value);
  }
  static constexpr Value Value_MIN =
    Vote_Value_Value_MIN;
  static constexpr Value Value_MAX =
    Vote_Value_Value_MAX;
  static constexpr int Value_ARRAYSIZE =
    Vote_Value_Value_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Value_descriptor() {
    return Vote_Value_descriptor();
  }
  template<typename T>
  static inline const std::string& Value_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Value>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Value_Name.");
    return Vote_Value_Name(enum_t_value);
  }
  static inline bool Value_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Value* value) {
    return Vote_Value_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIdFieldNumber = 1,
    kProposalIdFieldNumber = 3,
    kTotalGovernanceTokenWeightFieldNumber = 6,
    kTimestampFieldNumber = 4,
    kTotalGovernanceTokenBalanceFieldNumber = 5,
    kValueFieldNumber = 2,
  };
  // string party_id = 1 [json_name = "partyId", (.validator.field) = {
  void clear_party_id();
  const std::string& party_id() const;
  void set_party_id(const std::string& value);
  void set_party_id(std::string&& value);
  void set_party_id(const char* value);
  void set_party_id(const char* value, size_t size);
  std::string* mutable_party_id();
  std::string* release_party_id();
  void set_allocated_party_id(std::string* party_id);
  private:
  const std::string& _internal_party_id() const;
  void _internal_set_party_id(const std::string& value);
  std::string* _internal_mutable_party_id();
  public:

  // string proposal_id = 3 [json_name = "proposalId", (.validator.field) = {
  void clear_proposal_id();
  const std::string& proposal_id() const;
  void set_proposal_id(const std::string& value);
  void set_proposal_id(std::string&& value);
  void set_proposal_id(const char* value);
  void set_proposal_id(const char* value, size_t size);
  std::string* mutable_proposal_id();
  std::string* release_proposal_id();
  void set_allocated_proposal_id(std::string* proposal_id);
  private:
  const std::string& _internal_proposal_id() const;
  void _internal_set_proposal_id(const std::string& value);
  std::string* _internal_mutable_proposal_id();
  public:

  // string total_governance_token_weight = 6 [json_name = "totalGovernanceTokenWeight"];
  void clear_total_governance_token_weight();
  const std::string& total_governance_token_weight() const;
  void set_total_governance_token_weight(const std::string& value);
  void set_total_governance_token_weight(std::string&& value);
  void set_total_governance_token_weight(const char* value);
  void set_total_governance_token_weight(const char* value, size_t size);
  std::string* mutable_total_governance_token_weight();
  std::string* release_total_governance_token_weight();
  void set_allocated_total_governance_token_weight(std::string* total_governance_token_weight);
  private:
  const std::string& _internal_total_governance_token_weight() const;
  void _internal_set_total_governance_token_weight(const std::string& value);
  std::string* _internal_mutable_total_governance_token_weight();
  public:

  // int64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 total_governance_token_balance = 5 [json_name = "totalGovernanceTokenBalance"];
  void clear_total_governance_token_balance();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_governance_token_balance() const;
  void set_total_governance_token_balance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_governance_token_balance() const;
  void _internal_set_total_governance_token_balance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.Vote.Value value = 2 [json_name = "value", (.validator.field) = {
  void clear_value();
  ::vega::Vote_Value value() const;
  void set_value(::vega::Vote_Value value);
  private:
  ::vega::Vote_Value _internal_value() const;
  void _internal_set_value(::vega::Vote_Value value);
  public:

  // @@protoc_insertion_point(class_scope:vega.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr party_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposal_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_governance_token_weight_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_governance_token_balance_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_governance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FutureProduct

// string maturity = 1 [json_name = "maturity", (.validator.field) = {
inline void FutureProduct::clear_maturity() {
  maturity_.ClearToEmpty();
}
inline const std::string& FutureProduct::maturity() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.maturity)
  return _internal_maturity();
}
inline void FutureProduct::set_maturity(const std::string& value) {
  _internal_set_maturity(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.maturity)
}
inline std::string* FutureProduct::mutable_maturity() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.maturity)
  return _internal_mutable_maturity();
}
inline const std::string& FutureProduct::_internal_maturity() const {
  return maturity_.Get();
}
inline void FutureProduct::_internal_set_maturity(const std::string& value) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_maturity(std::string&& value) {

  maturity_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.maturity)
}
inline void FutureProduct::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.maturity)
}
inline void FutureProduct::set_maturity(const char* value,
    size_t size) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.maturity)
}
inline std::string* FutureProduct::_internal_mutable_maturity() {

  return maturity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.maturity)
  return maturity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_maturity(std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maturity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.maturity)
}

// string settlement_asset = 2 [json_name = "settlementAsset", (.validator.field) = {
inline void FutureProduct::clear_settlement_asset() {
  settlement_asset_.ClearToEmpty();
}
inline const std::string& FutureProduct::settlement_asset() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.settlement_asset)
  return _internal_settlement_asset();
}
inline void FutureProduct::set_settlement_asset(const std::string& value) {
  _internal_set_settlement_asset(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.settlement_asset)
}
inline std::string* FutureProduct::mutable_settlement_asset() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.settlement_asset)
  return _internal_mutable_settlement_asset();
}
inline const std::string& FutureProduct::_internal_settlement_asset() const {
  return settlement_asset_.Get();
}
inline void FutureProduct::_internal_set_settlement_asset(const std::string& value) {

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_settlement_asset(std::string&& value) {

  settlement_asset_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.settlement_asset)
}
inline void FutureProduct::set_settlement_asset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.settlement_asset)
}
inline void FutureProduct::set_settlement_asset(const char* value,
    size_t size) {

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.settlement_asset)
}
inline std::string* FutureProduct::_internal_mutable_settlement_asset() {

  return settlement_asset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_settlement_asset() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.settlement_asset)
  return settlement_asset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_settlement_asset(std::string* settlement_asset) {
  if (settlement_asset != nullptr) {

  } else {

  }
  settlement_asset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settlement_asset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.settlement_asset)
}

// string quote_name = 3 [json_name = "quoteName", (.validator.field) = {
inline void FutureProduct::clear_quote_name() {
  quote_name_.ClearToEmpty();
}
inline const std::string& FutureProduct::quote_name() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.quote_name)
  return _internal_quote_name();
}
inline void FutureProduct::set_quote_name(const std::string& value) {
  _internal_set_quote_name(value);
  // @@protoc_insertion_point(field_set:vega.FutureProduct.quote_name)
}
inline std::string* FutureProduct::mutable_quote_name() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.quote_name)
  return _internal_mutable_quote_name();
}
inline const std::string& FutureProduct::_internal_quote_name() const {
  return quote_name_.Get();
}
inline void FutureProduct::_internal_set_quote_name(const std::string& value) {

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FutureProduct::set_quote_name(std::string&& value) {

  quote_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FutureProduct.quote_name)
}
inline void FutureProduct::set_quote_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FutureProduct.quote_name)
}
inline void FutureProduct::set_quote_name(const char* value,
    size_t size) {

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FutureProduct.quote_name)
}
inline std::string* FutureProduct::_internal_mutable_quote_name() {

  return quote_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FutureProduct::release_quote_name() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.quote_name)
  return quote_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FutureProduct::set_allocated_quote_name(std::string* quote_name) {
  if (quote_name != nullptr) {

  } else {

  }
  quote_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quote_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.quote_name)
}

// .oracles.v1.OracleSpecConfiguration oracle_spec = 5 [json_name = "oracleSpec"];
inline bool FutureProduct::_internal_has_oracle_spec() const {
  return this != internal_default_instance() && oracle_spec_ != nullptr;
}
inline bool FutureProduct::has_oracle_spec() const {
  return _internal_has_oracle_spec();
}
inline const ::oracles::v1::OracleSpecConfiguration& FutureProduct::_internal_oracle_spec() const {
  const ::oracles::v1::OracleSpecConfiguration* p = oracle_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::oracles::v1::OracleSpecConfiguration&>(
      ::oracles::v1::_OracleSpecConfiguration_default_instance_);
}
inline const ::oracles::v1::OracleSpecConfiguration& FutureProduct::oracle_spec() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.oracle_spec)
  return _internal_oracle_spec();
}
inline void FutureProduct::unsafe_arena_set_allocated_oracle_spec(
    ::oracles::v1::OracleSpecConfiguration* oracle_spec) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_);
  }
  oracle_spec_ = oracle_spec;
  if (oracle_spec) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.FutureProduct.oracle_spec)
}
inline ::oracles::v1::OracleSpecConfiguration* FutureProduct::release_oracle_spec() {

  ::oracles::v1::OracleSpecConfiguration* temp = oracle_spec_;
  oracle_spec_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::oracles::v1::OracleSpecConfiguration* FutureProduct::unsafe_arena_release_oracle_spec() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.oracle_spec)

  ::oracles::v1::OracleSpecConfiguration* temp = oracle_spec_;
  oracle_spec_ = nullptr;
  return temp;
}
inline ::oracles::v1::OracleSpecConfiguration* FutureProduct::_internal_mutable_oracle_spec() {

  if (oracle_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::oracles::v1::OracleSpecConfiguration>(GetArena());
    oracle_spec_ = p;
  }
  return oracle_spec_;
}
inline ::oracles::v1::OracleSpecConfiguration* FutureProduct::mutable_oracle_spec() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.oracle_spec)
  return _internal_mutable_oracle_spec();
}
inline void FutureProduct::set_allocated_oracle_spec(::oracles::v1::OracleSpecConfiguration* oracle_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_);
  }
  if (oracle_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec)->GetArena();
    if (message_arena != submessage_arena) {
      oracle_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_spec, submessage_arena);
    }

  } else {

  }
  oracle_spec_ = oracle_spec;
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.oracle_spec)
}

// .vega.OracleSpecToFutureBinding oracle_spec_binding = 6 [json_name = "oracleSpecBinding"];
inline bool FutureProduct::_internal_has_oracle_spec_binding() const {
  return this != internal_default_instance() && oracle_spec_binding_ != nullptr;
}
inline bool FutureProduct::has_oracle_spec_binding() const {
  return _internal_has_oracle_spec_binding();
}
inline const ::vega::OracleSpecToFutureBinding& FutureProduct::_internal_oracle_spec_binding() const {
  const ::vega::OracleSpecToFutureBinding* p = oracle_spec_binding_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::OracleSpecToFutureBinding&>(
      ::vega::_OracleSpecToFutureBinding_default_instance_);
}
inline const ::vega::OracleSpecToFutureBinding& FutureProduct::oracle_spec_binding() const {
  // @@protoc_insertion_point(field_get:vega.FutureProduct.oracle_spec_binding)
  return _internal_oracle_spec_binding();
}
inline void FutureProduct::unsafe_arena_set_allocated_oracle_spec_binding(
    ::vega::OracleSpecToFutureBinding* oracle_spec_binding) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_binding_);
  }
  oracle_spec_binding_ = oracle_spec_binding;
  if (oracle_spec_binding) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.FutureProduct.oracle_spec_binding)
}
inline ::vega::OracleSpecToFutureBinding* FutureProduct::release_oracle_spec_binding() {

  ::vega::OracleSpecToFutureBinding* temp = oracle_spec_binding_;
  oracle_spec_binding_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::OracleSpecToFutureBinding* FutureProduct::unsafe_arena_release_oracle_spec_binding() {
  // @@protoc_insertion_point(field_release:vega.FutureProduct.oracle_spec_binding)

  ::vega::OracleSpecToFutureBinding* temp = oracle_spec_binding_;
  oracle_spec_binding_ = nullptr;
  return temp;
}
inline ::vega::OracleSpecToFutureBinding* FutureProduct::_internal_mutable_oracle_spec_binding() {

  if (oracle_spec_binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::OracleSpecToFutureBinding>(GetArena());
    oracle_spec_binding_ = p;
  }
  return oracle_spec_binding_;
}
inline ::vega::OracleSpecToFutureBinding* FutureProduct::mutable_oracle_spec_binding() {
  // @@protoc_insertion_point(field_mutable:vega.FutureProduct.oracle_spec_binding)
  return _internal_mutable_oracle_spec_binding();
}
inline void FutureProduct::set_allocated_oracle_spec_binding(::vega::OracleSpecToFutureBinding* oracle_spec_binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_binding_);
  }
  if (oracle_spec_binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_binding)->GetArena();
    if (message_arena != submessage_arena) {
      oracle_spec_binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_spec_binding, submessage_arena);
    }

  } else {

  }
  oracle_spec_binding_ = oracle_spec_binding;
  // @@protoc_insertion_point(field_set_allocated:vega.FutureProduct.oracle_spec_binding)
}

// -------------------------------------------------------------------

// InstrumentConfiguration

// string name = 1 [json_name = "name", (.validator.field) = {
inline void InstrumentConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& InstrumentConfiguration::name() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.name)
  return _internal_name();
}
inline void InstrumentConfiguration::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.name)
}
inline std::string* InstrumentConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& InstrumentConfiguration::_internal_name() const {
  return name_.Get();
}
inline void InstrumentConfiguration::_internal_set_name(const std::string& value) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InstrumentConfiguration::set_name(std::string&& value) {

  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.name)
}
inline void InstrumentConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.name)
}
inline void InstrumentConfiguration::set_name(const char* value,
    size_t size) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.name)
}
inline std::string* InstrumentConfiguration::_internal_mutable_name() {

  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InstrumentConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.name)
}

// string code = 2 [json_name = "code", (.validator.field) = {
inline void InstrumentConfiguration::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& InstrumentConfiguration::code() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.code)
  return _internal_code();
}
inline void InstrumentConfiguration::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:vega.InstrumentConfiguration.code)
}
inline std::string* InstrumentConfiguration::mutable_code() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.code)
  return _internal_mutable_code();
}
inline const std::string& InstrumentConfiguration::_internal_code() const {
  return code_.Get();
}
inline void InstrumentConfiguration::_internal_set_code(const std::string& value) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void InstrumentConfiguration::set_code(std::string&& value) {

  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.InstrumentConfiguration.code)
}
inline void InstrumentConfiguration::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.InstrumentConfiguration.code)
}
inline void InstrumentConfiguration::set_code(const char* value,
    size_t size) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentConfiguration.code)
}
inline std::string* InstrumentConfiguration::_internal_mutable_code() {

  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* InstrumentConfiguration::release_code() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InstrumentConfiguration::set_allocated_code(std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.InstrumentConfiguration.code)
}

// .vega.FutureProduct future = 100 [json_name = "future"];
inline bool InstrumentConfiguration::_internal_has_future() const {
  return product_case() == kFuture;
}
inline bool InstrumentConfiguration::has_future() const {
  return _internal_has_future();
}
inline void InstrumentConfiguration::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void InstrumentConfiguration::clear_future() {
  if (_internal_has_future()) {
    if (GetArena() == nullptr) {
      delete product_.future_;
    }
    clear_has_product();
  }
}
inline ::vega::FutureProduct* InstrumentConfiguration::release_future() {
  // @@protoc_insertion_point(field_release:vega.InstrumentConfiguration.future)
  if (_internal_has_future()) {
    clear_has_product();
      ::vega::FutureProduct* temp = product_.future_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::FutureProduct& InstrumentConfiguration::_internal_future() const {
  return _internal_has_future()
      ? *product_.future_
      : reinterpret_cast< ::vega::FutureProduct&>(::vega::_FutureProduct_default_instance_);
}
inline const ::vega::FutureProduct& InstrumentConfiguration::future() const {
  // @@protoc_insertion_point(field_get:vega.InstrumentConfiguration.future)
  return _internal_future();
}
inline ::vega::FutureProduct* InstrumentConfiguration::unsafe_arena_release_future() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.InstrumentConfiguration.future)
  if (_internal_has_future()) {
    clear_has_product();
    ::vega::FutureProduct* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InstrumentConfiguration::unsafe_arena_set_allocated_future(::vega::FutureProduct* future) {
  clear_product();
  if (future) {
    set_has_future();
    product_.future_ = future;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.InstrumentConfiguration.future)
}
inline ::vega::FutureProduct* InstrumentConfiguration::_internal_mutable_future() {
  if (!_internal_has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::FutureProduct >(GetArena());
  }
  return product_.future_;
}
inline ::vega::FutureProduct* InstrumentConfiguration::mutable_future() {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentConfiguration.future)
  return _internal_mutable_future();
}

inline bool InstrumentConfiguration::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void InstrumentConfiguration::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline InstrumentConfiguration::ProductCase InstrumentConfiguration::product_case() const {
  return InstrumentConfiguration::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NewMarketConfiguration

// .vega.InstrumentConfiguration instrument = 1 [json_name = "instrument", (.validator.field) = {
inline bool NewMarketConfiguration::_internal_has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline bool NewMarketConfiguration::has_instrument() const {
  return _internal_has_instrument();
}
inline void NewMarketConfiguration::clear_instrument() {
  if (GetArena() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::InstrumentConfiguration& NewMarketConfiguration::_internal_instrument() const {
  const ::vega::InstrumentConfiguration* p = instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::InstrumentConfiguration&>(
      ::vega::_InstrumentConfiguration_default_instance_);
}
inline const ::vega::InstrumentConfiguration& NewMarketConfiguration::instrument() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.instrument)
  return _internal_instrument();
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_instrument(
    ::vega::InstrumentConfiguration* instrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instrument_);
  }
  instrument_ = instrument;
  if (instrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.instrument)
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::release_instrument() {

  ::vega::InstrumentConfiguration* temp = instrument_;
  instrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.instrument)

  ::vega::InstrumentConfiguration* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::_internal_mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentConfiguration>(GetArena());
    instrument_ = p;
  }
  return instrument_;
}
inline ::vega::InstrumentConfiguration* NewMarketConfiguration::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.instrument)
  return _internal_mutable_instrument();
}
inline void NewMarketConfiguration::set_allocated_instrument(::vega::InstrumentConfiguration* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.instrument)
}

// uint64 decimal_places = 2 [json_name = "decimalPlaces", (.validator.field) = {
inline void NewMarketConfiguration::clear_decimal_places() {
  decimal_places_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketConfiguration::_internal_decimal_places() const {
  return decimal_places_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketConfiguration::decimal_places() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.decimal_places)
  return _internal_decimal_places();
}
inline void NewMarketConfiguration::_internal_set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  decimal_places_ = value;
}
inline void NewMarketConfiguration::set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_decimal_places(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.decimal_places)
}

// repeated string metadata = 3 [json_name = "metadata"];
inline int NewMarketConfiguration::_internal_metadata_size() const {
  return metadata_.size();
}
inline int NewMarketConfiguration::metadata_size() const {
  return _internal_metadata_size();
}
inline void NewMarketConfiguration::clear_metadata() {
  metadata_.Clear();
}
inline std::string* NewMarketConfiguration::add_metadata() {
  // @@protoc_insertion_point(field_add_mutable:vega.NewMarketConfiguration.metadata)
  return _internal_add_metadata();
}
inline const std::string& NewMarketConfiguration::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const std::string& NewMarketConfiguration::metadata(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.metadata)
  return _internal_metadata(index);
}
inline std::string* NewMarketConfiguration::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.metadata)
  return metadata_.Mutable(index);
}
inline void NewMarketConfiguration::set_metadata(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(value);
}
inline void NewMarketConfiguration::set_metadata(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.NewMarketConfiguration.metadata)
  metadata_.Mutable(index)->assign(std::move(value));
}
inline void NewMarketConfiguration::set_metadata(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::set_metadata(int index, const char* value, size_t size) {
  metadata_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketConfiguration.metadata)
}
inline std::string* NewMarketConfiguration::_internal_add_metadata() {
  return metadata_.Add();
}
inline void NewMarketConfiguration::add_metadata(const std::string& value) {
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(std::string&& value) {
  metadata_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  metadata_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.NewMarketConfiguration.metadata)
}
inline void NewMarketConfiguration::add_metadata(const char* value, size_t size) {
  metadata_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.NewMarketConfiguration.metadata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NewMarketConfiguration::metadata() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketConfiguration.metadata)
  return metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NewMarketConfiguration::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketConfiguration.metadata)
  return &metadata_;
}

// .vega.PriceMonitoringParameters price_monitoring_parameters = 4 [json_name = "priceMonitoringParameters"];
inline bool NewMarketConfiguration::_internal_has_price_monitoring_parameters() const {
  return this != internal_default_instance() && price_monitoring_parameters_ != nullptr;
}
inline bool NewMarketConfiguration::has_price_monitoring_parameters() const {
  return _internal_has_price_monitoring_parameters();
}
inline const ::vega::PriceMonitoringParameters& NewMarketConfiguration::_internal_price_monitoring_parameters() const {
  const ::vega::PriceMonitoringParameters* p = price_monitoring_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringParameters&>(
      ::vega::_PriceMonitoringParameters_default_instance_);
}
inline const ::vega::PriceMonitoringParameters& NewMarketConfiguration::price_monitoring_parameters() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.price_monitoring_parameters)
  return _internal_price_monitoring_parameters();
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_price_monitoring_parameters(
    ::vega::PriceMonitoringParameters* price_monitoring_parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(price_monitoring_parameters_);
  }
  price_monitoring_parameters_ = price_monitoring_parameters;
  if (price_monitoring_parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.price_monitoring_parameters)
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::release_price_monitoring_parameters() {

  ::vega::PriceMonitoringParameters* temp = price_monitoring_parameters_;
  price_monitoring_parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::unsafe_arena_release_price_monitoring_parameters() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.price_monitoring_parameters)

  ::vega::PriceMonitoringParameters* temp = price_monitoring_parameters_;
  price_monitoring_parameters_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::_internal_mutable_price_monitoring_parameters() {

  if (price_monitoring_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringParameters>(GetArena());
    price_monitoring_parameters_ = p;
  }
  return price_monitoring_parameters_;
}
inline ::vega::PriceMonitoringParameters* NewMarketConfiguration::mutable_price_monitoring_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.price_monitoring_parameters)
  return _internal_mutable_price_monitoring_parameters();
}
inline void NewMarketConfiguration::set_allocated_price_monitoring_parameters(::vega::PriceMonitoringParameters* price_monitoring_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(price_monitoring_parameters_);
  }
  if (price_monitoring_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(price_monitoring_parameters)->GetArena();
    if (message_arena != submessage_arena) {
      price_monitoring_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_monitoring_parameters, submessage_arena);
    }

  } else {

  }
  price_monitoring_parameters_ = price_monitoring_parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.price_monitoring_parameters)
}

// .vega.LiquidityMonitoringParameters liquidity_monitoring_parameters = 5 [json_name = "liquidityMonitoringParameters"];
inline bool NewMarketConfiguration::_internal_has_liquidity_monitoring_parameters() const {
  return this != internal_default_instance() && liquidity_monitoring_parameters_ != nullptr;
}
inline bool NewMarketConfiguration::has_liquidity_monitoring_parameters() const {
  return _internal_has_liquidity_monitoring_parameters();
}
inline const ::vega::LiquidityMonitoringParameters& NewMarketConfiguration::_internal_liquidity_monitoring_parameters() const {
  const ::vega::LiquidityMonitoringParameters* p = liquidity_monitoring_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::LiquidityMonitoringParameters&>(
      ::vega::_LiquidityMonitoringParameters_default_instance_);
}
inline const ::vega::LiquidityMonitoringParameters& NewMarketConfiguration::liquidity_monitoring_parameters() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.liquidity_monitoring_parameters)
  return _internal_liquidity_monitoring_parameters();
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_liquidity_monitoring_parameters(
    ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquidity_monitoring_parameters_);
  }
  liquidity_monitoring_parameters_ = liquidity_monitoring_parameters;
  if (liquidity_monitoring_parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.liquidity_monitoring_parameters)
}
inline ::vega::LiquidityMonitoringParameters* NewMarketConfiguration::release_liquidity_monitoring_parameters() {

  ::vega::LiquidityMonitoringParameters* temp = liquidity_monitoring_parameters_;
  liquidity_monitoring_parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::LiquidityMonitoringParameters* NewMarketConfiguration::unsafe_arena_release_liquidity_monitoring_parameters() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.liquidity_monitoring_parameters)

  ::vega::LiquidityMonitoringParameters* temp = liquidity_monitoring_parameters_;
  liquidity_monitoring_parameters_ = nullptr;
  return temp;
}
inline ::vega::LiquidityMonitoringParameters* NewMarketConfiguration::_internal_mutable_liquidity_monitoring_parameters() {

  if (liquidity_monitoring_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::LiquidityMonitoringParameters>(GetArena());
    liquidity_monitoring_parameters_ = p;
  }
  return liquidity_monitoring_parameters_;
}
inline ::vega::LiquidityMonitoringParameters* NewMarketConfiguration::mutable_liquidity_monitoring_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.liquidity_monitoring_parameters)
  return _internal_mutable_liquidity_monitoring_parameters();
}
inline void NewMarketConfiguration::set_allocated_liquidity_monitoring_parameters(::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquidity_monitoring_parameters_);
  }
  if (liquidity_monitoring_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquidity_monitoring_parameters)->GetArena();
    if (message_arena != submessage_arena) {
      liquidity_monitoring_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquidity_monitoring_parameters, submessage_arena);
    }

  } else {

  }
  liquidity_monitoring_parameters_ = liquidity_monitoring_parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketConfiguration.liquidity_monitoring_parameters)
}

// .vega.SimpleModelParams simple = 100 [json_name = "simple"];
inline bool NewMarketConfiguration::_internal_has_simple() const {
  return risk_parameters_case() == kSimple;
}
inline bool NewMarketConfiguration::has_simple() const {
  return _internal_has_simple();
}
inline void NewMarketConfiguration::set_has_simple() {
  _oneof_case_[0] = kSimple;
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::release_simple() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.simple)
  if (_internal_has_simple()) {
    clear_has_risk_parameters();
      ::vega::SimpleModelParams* temp = risk_parameters_.simple_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    risk_parameters_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleModelParams& NewMarketConfiguration::_internal_simple() const {
  return _internal_has_simple()
      ? *risk_parameters_.simple_
      : reinterpret_cast< ::vega::SimpleModelParams&>(::vega::_SimpleModelParams_default_instance_);
}
inline const ::vega::SimpleModelParams& NewMarketConfiguration::simple() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.simple)
  return _internal_simple();
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::unsafe_arena_release_simple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.simple)
  if (_internal_has_simple()) {
    clear_has_risk_parameters();
    ::vega::SimpleModelParams* temp = risk_parameters_.simple_;
    risk_parameters_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_simple(::vega::SimpleModelParams* simple) {
  clear_risk_parameters();
  if (simple) {
    set_has_simple();
    risk_parameters_.simple_ = simple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.simple)
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::_internal_mutable_simple() {
  if (!_internal_has_simple()) {
    clear_risk_parameters();
    set_has_simple();
    risk_parameters_.simple_ = CreateMaybeMessage< ::vega::SimpleModelParams >(GetArena());
  }
  return risk_parameters_.simple_;
}
inline ::vega::SimpleModelParams* NewMarketConfiguration::mutable_simple() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.simple)
  return _internal_mutable_simple();
}

// .vega.LogNormalRiskModel log_normal = 101 [json_name = "logNormal"];
inline bool NewMarketConfiguration::_internal_has_log_normal() const {
  return risk_parameters_case() == kLogNormal;
}
inline bool NewMarketConfiguration::has_log_normal() const {
  return _internal_has_log_normal();
}
inline void NewMarketConfiguration::set_has_log_normal() {
  _oneof_case_[0] = kLogNormal;
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::release_log_normal() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.log_normal)
  if (_internal_has_log_normal()) {
    clear_has_risk_parameters();
      ::vega::LogNormalRiskModel* temp = risk_parameters_.log_normal_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    risk_parameters_.log_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& NewMarketConfiguration::_internal_log_normal() const {
  return _internal_has_log_normal()
      ? *risk_parameters_.log_normal_
      : reinterpret_cast< ::vega::LogNormalRiskModel&>(::vega::_LogNormalRiskModel_default_instance_);
}
inline const ::vega::LogNormalRiskModel& NewMarketConfiguration::log_normal() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.log_normal)
  return _internal_log_normal();
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::unsafe_arena_release_log_normal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.log_normal)
  if (_internal_has_log_normal()) {
    clear_has_risk_parameters();
    ::vega::LogNormalRiskModel* temp = risk_parameters_.log_normal_;
    risk_parameters_.log_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_log_normal(::vega::LogNormalRiskModel* log_normal) {
  clear_risk_parameters();
  if (log_normal) {
    set_has_log_normal();
    risk_parameters_.log_normal_ = log_normal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.log_normal)
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::_internal_mutable_log_normal() {
  if (!_internal_has_log_normal()) {
    clear_risk_parameters();
    set_has_log_normal();
    risk_parameters_.log_normal_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(GetArena());
  }
  return risk_parameters_.log_normal_;
}
inline ::vega::LogNormalRiskModel* NewMarketConfiguration::mutable_log_normal() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.log_normal)
  return _internal_mutable_log_normal();
}

// .vega.ContinuousTrading continuous = 200 [json_name = "continuous"];
inline bool NewMarketConfiguration::_internal_has_continuous() const {
  return trading_mode_case() == kContinuous;
}
inline bool NewMarketConfiguration::has_continuous() const {
  return _internal_has_continuous();
}
inline void NewMarketConfiguration::set_has_continuous() {
  _oneof_case_[1] = kContinuous;
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.continuous)
  if (_internal_has_continuous()) {
    clear_has_trading_mode();
      ::vega::ContinuousTrading* temp = trading_mode_.continuous_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    trading_mode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& NewMarketConfiguration::_internal_continuous() const {
  return _internal_has_continuous()
      ? *trading_mode_.continuous_
      : reinterpret_cast< ::vega::ContinuousTrading&>(::vega::_ContinuousTrading_default_instance_);
}
inline const ::vega::ContinuousTrading& NewMarketConfiguration::continuous() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.continuous)
  return _internal_continuous();
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::unsafe_arena_release_continuous() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.continuous)
  if (_internal_has_continuous()) {
    clear_has_trading_mode();
    ::vega::ContinuousTrading* temp = trading_mode_.continuous_;
    trading_mode_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_continuous(::vega::ContinuousTrading* continuous) {
  clear_trading_mode();
  if (continuous) {
    set_has_continuous();
    trading_mode_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.continuous)
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::_internal_mutable_continuous() {
  if (!_internal_has_continuous()) {
    clear_trading_mode();
    set_has_continuous();
    trading_mode_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(GetArena());
  }
  return trading_mode_.continuous_;
}
inline ::vega::ContinuousTrading* NewMarketConfiguration::mutable_continuous() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.continuous)
  return _internal_mutable_continuous();
}

// .vega.DiscreteTrading discrete = 201 [json_name = "discrete"];
inline bool NewMarketConfiguration::_internal_has_discrete() const {
  return trading_mode_case() == kDiscrete;
}
inline bool NewMarketConfiguration::has_discrete() const {
  return _internal_has_discrete();
}
inline void NewMarketConfiguration::set_has_discrete() {
  _oneof_case_[1] = kDiscrete;
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.NewMarketConfiguration.discrete)
  if (_internal_has_discrete()) {
    clear_has_trading_mode();
      ::vega::DiscreteTrading* temp = trading_mode_.discrete_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    trading_mode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& NewMarketConfiguration::_internal_discrete() const {
  return _internal_has_discrete()
      ? *trading_mode_.discrete_
      : reinterpret_cast< ::vega::DiscreteTrading&>(::vega::_DiscreteTrading_default_instance_);
}
inline const ::vega::DiscreteTrading& NewMarketConfiguration::discrete() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketConfiguration.discrete)
  return _internal_discrete();
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::unsafe_arena_release_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.NewMarketConfiguration.discrete)
  if (_internal_has_discrete()) {
    clear_has_trading_mode();
    ::vega::DiscreteTrading* temp = trading_mode_.discrete_;
    trading_mode_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewMarketConfiguration::unsafe_arena_set_allocated_discrete(::vega::DiscreteTrading* discrete) {
  clear_trading_mode();
  if (discrete) {
    set_has_discrete();
    trading_mode_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarketConfiguration.discrete)
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::_internal_mutable_discrete() {
  if (!_internal_has_discrete()) {
    clear_trading_mode();
    set_has_discrete();
    trading_mode_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(GetArena());
  }
  return trading_mode_.discrete_;
}
inline ::vega::DiscreteTrading* NewMarketConfiguration::mutable_discrete() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketConfiguration.discrete)
  return _internal_mutable_discrete();
}

inline bool NewMarketConfiguration::has_risk_parameters() const {
  return risk_parameters_case() != RISK_PARAMETERS_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_risk_parameters() {
  _oneof_case_[0] = RISK_PARAMETERS_NOT_SET;
}
inline bool NewMarketConfiguration::has_trading_mode() const {
  return trading_mode_case() != TRADING_MODE_NOT_SET;
}
inline void NewMarketConfiguration::clear_has_trading_mode() {
  _oneof_case_[1] = TRADING_MODE_NOT_SET;
}
inline NewMarketConfiguration::RiskParametersCase NewMarketConfiguration::risk_parameters_case() const {
  return NewMarketConfiguration::RiskParametersCase(_oneof_case_[0]);
}
inline NewMarketConfiguration::TradingModeCase NewMarketConfiguration::trading_mode_case() const {
  return NewMarketConfiguration::TradingModeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// NewMarketCommitment

// uint64 commitment_amount = 1 [json_name = "commitmentAmount"];
inline void NewMarketCommitment::clear_commitment_amount() {
  commitment_amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketCommitment::_internal_commitment_amount() const {
  return commitment_amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NewMarketCommitment::commitment_amount() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.commitment_amount)
  return _internal_commitment_amount();
}
inline void NewMarketCommitment::_internal_set_commitment_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  commitment_amount_ = value;
}
inline void NewMarketCommitment::set_commitment_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_commitment_amount(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketCommitment.commitment_amount)
}

// string fee = 2 [json_name = "fee"];
inline void NewMarketCommitment::clear_fee() {
  fee_.ClearToEmpty();
}
inline const std::string& NewMarketCommitment::fee() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.fee)
  return _internal_fee();
}
inline void NewMarketCommitment::set_fee(const std::string& value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketCommitment.fee)
}
inline std::string* NewMarketCommitment::mutable_fee() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.fee)
  return _internal_mutable_fee();
}
inline const std::string& NewMarketCommitment::_internal_fee() const {
  return fee_.Get();
}
inline void NewMarketCommitment::_internal_set_fee(const std::string& value) {

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NewMarketCommitment::set_fee(std::string&& value) {

  fee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.NewMarketCommitment.fee)
}
inline void NewMarketCommitment::set_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.NewMarketCommitment.fee)
}
inline void NewMarketCommitment::set_fee(const char* value,
    size_t size) {

  fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketCommitment.fee)
}
inline std::string* NewMarketCommitment::_internal_mutable_fee() {

  return fee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NewMarketCommitment::release_fee() {
  // @@protoc_insertion_point(field_release:vega.NewMarketCommitment.fee)
  return fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewMarketCommitment::set_allocated_fee(std::string* fee) {
  if (fee != nullptr) {

  } else {

  }
  fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketCommitment.fee)
}

// repeated .vega.LiquidityOrder sells = 3 [json_name = "sells"];
inline int NewMarketCommitment::_internal_sells_size() const {
  return sells_.size();
}
inline int NewMarketCommitment::sells_size() const {
  return _internal_sells_size();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.sells)
  return sells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
NewMarketCommitment::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketCommitment.sells)
  return &sells_;
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::_internal_sells(int index) const {
  return sells_.Get(index);
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::sells(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.sells)
  return _internal_sells(index);
}
inline ::vega::LiquidityOrder* NewMarketCommitment::_internal_add_sells() {
  return sells_.Add();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::add_sells() {
  // @@protoc_insertion_point(field_add:vega.NewMarketCommitment.sells)
  return _internal_add_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
NewMarketCommitment::sells() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketCommitment.sells)
  return sells_;
}

// repeated .vega.LiquidityOrder buys = 4 [json_name = "buys"];
inline int NewMarketCommitment::_internal_buys_size() const {
  return buys_.size();
}
inline int NewMarketCommitment::buys_size() const {
  return _internal_buys_size();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.buys)
  return buys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >*
NewMarketCommitment::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:vega.NewMarketCommitment.buys)
  return &buys_;
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::_internal_buys(int index) const {
  return buys_.Get(index);
}
inline const ::vega::LiquidityOrder& NewMarketCommitment::buys(int index) const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.buys)
  return _internal_buys(index);
}
inline ::vega::LiquidityOrder* NewMarketCommitment::_internal_add_buys() {
  return buys_.Add();
}
inline ::vega::LiquidityOrder* NewMarketCommitment::add_buys() {
  // @@protoc_insertion_point(field_add:vega.NewMarketCommitment.buys)
  return _internal_add_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::LiquidityOrder >&
NewMarketCommitment::buys() const {
  // @@protoc_insertion_point(field_list:vega.NewMarketCommitment.buys)
  return buys_;
}

// string reference = 5 [json_name = "reference"];
inline void NewMarketCommitment::clear_reference() {
  reference_.ClearToEmpty();
}
inline const std::string& NewMarketCommitment::reference() const {
  // @@protoc_insertion_point(field_get:vega.NewMarketCommitment.reference)
  return _internal_reference();
}
inline void NewMarketCommitment::set_reference(const std::string& value) {
  _internal_set_reference(value);
  // @@protoc_insertion_point(field_set:vega.NewMarketCommitment.reference)
}
inline std::string* NewMarketCommitment::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarketCommitment.reference)
  return _internal_mutable_reference();
}
inline const std::string& NewMarketCommitment::_internal_reference() const {
  return reference_.Get();
}
inline void NewMarketCommitment::_internal_set_reference(const std::string& value) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NewMarketCommitment::set_reference(std::string&& value) {

  reference_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.NewMarketCommitment.reference)
}
inline void NewMarketCommitment::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.NewMarketCommitment.reference)
}
inline void NewMarketCommitment::set_reference(const char* value,
    size_t size) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.NewMarketCommitment.reference)
}
inline std::string* NewMarketCommitment::_internal_mutable_reference() {

  return reference_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NewMarketCommitment::release_reference() {
  // @@protoc_insertion_point(field_release:vega.NewMarketCommitment.reference)
  return reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NewMarketCommitment::set_allocated_reference(std::string* reference) {
  if (reference != nullptr) {

  } else {

  }
  reference_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarketCommitment.reference)
}

// -------------------------------------------------------------------

// NewMarket

// .vega.NewMarketConfiguration changes = 1 [json_name = "changes", (.validator.field) = {
inline bool NewMarket::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool NewMarket::has_changes() const {
  return _internal_has_changes();
}
inline void NewMarket::clear_changes() {
  if (GetArena() == nullptr && changes_ != nullptr) {
    delete changes_;
  }
  changes_ = nullptr;
}
inline const ::vega::NewMarketConfiguration& NewMarket::_internal_changes() const {
  const ::vega::NewMarketConfiguration* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NewMarketConfiguration&>(
      ::vega::_NewMarketConfiguration_default_instance_);
}
inline const ::vega::NewMarketConfiguration& NewMarket::changes() const {
  // @@protoc_insertion_point(field_get:vega.NewMarket.changes)
  return _internal_changes();
}
inline void NewMarket::unsafe_arena_set_allocated_changes(
    ::vega::NewMarketConfiguration* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarket.changes)
}
inline ::vega::NewMarketConfiguration* NewMarket::release_changes() {

  ::vega::NewMarketConfiguration* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NewMarketConfiguration* NewMarket::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.changes)

  ::vega::NewMarketConfiguration* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NewMarketConfiguration* NewMarket::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NewMarketConfiguration>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::NewMarketConfiguration* NewMarket::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.changes)
  return _internal_mutable_changes();
}
inline void NewMarket::set_allocated_changes(::vega::NewMarketConfiguration* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete changes_;
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(changes);
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.changes)
}

// .vega.NewMarketCommitment liquidity_commitment = 2 [json_name = "liquidityCommitment"];
inline bool NewMarket::_internal_has_liquidity_commitment() const {
  return this != internal_default_instance() && liquidity_commitment_ != nullptr;
}
inline bool NewMarket::has_liquidity_commitment() const {
  return _internal_has_liquidity_commitment();
}
inline void NewMarket::clear_liquidity_commitment() {
  if (GetArena() == nullptr && liquidity_commitment_ != nullptr) {
    delete liquidity_commitment_;
  }
  liquidity_commitment_ = nullptr;
}
inline const ::vega::NewMarketCommitment& NewMarket::_internal_liquidity_commitment() const {
  const ::vega::NewMarketCommitment* p = liquidity_commitment_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NewMarketCommitment&>(
      ::vega::_NewMarketCommitment_default_instance_);
}
inline const ::vega::NewMarketCommitment& NewMarket::liquidity_commitment() const {
  // @@protoc_insertion_point(field_get:vega.NewMarket.liquidity_commitment)
  return _internal_liquidity_commitment();
}
inline void NewMarket::unsafe_arena_set_allocated_liquidity_commitment(
    ::vega::NewMarketCommitment* liquidity_commitment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquidity_commitment_);
  }
  liquidity_commitment_ = liquidity_commitment;
  if (liquidity_commitment) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewMarket.liquidity_commitment)
}
inline ::vega::NewMarketCommitment* NewMarket::release_liquidity_commitment() {

  ::vega::NewMarketCommitment* temp = liquidity_commitment_;
  liquidity_commitment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NewMarketCommitment* NewMarket::unsafe_arena_release_liquidity_commitment() {
  // @@protoc_insertion_point(field_release:vega.NewMarket.liquidity_commitment)

  ::vega::NewMarketCommitment* temp = liquidity_commitment_;
  liquidity_commitment_ = nullptr;
  return temp;
}
inline ::vega::NewMarketCommitment* NewMarket::_internal_mutable_liquidity_commitment() {

  if (liquidity_commitment_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NewMarketCommitment>(GetArena());
    liquidity_commitment_ = p;
  }
  return liquidity_commitment_;
}
inline ::vega::NewMarketCommitment* NewMarket::mutable_liquidity_commitment() {
  // @@protoc_insertion_point(field_mutable:vega.NewMarket.liquidity_commitment)
  return _internal_mutable_liquidity_commitment();
}
inline void NewMarket::set_allocated_liquidity_commitment(::vega::NewMarketCommitment* liquidity_commitment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete liquidity_commitment_;
  }
  if (liquidity_commitment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(liquidity_commitment);
    if (message_arena != submessage_arena) {
      liquidity_commitment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquidity_commitment, submessage_arena);
    }

  } else {

  }
  liquidity_commitment_ = liquidity_commitment;
  // @@protoc_insertion_point(field_set_allocated:vega.NewMarket.liquidity_commitment)
}

// -------------------------------------------------------------------

// UpdateMarket

// -------------------------------------------------------------------

// UpdateNetworkParameter

// .vega.NetworkParameter changes = 1 [json_name = "changes", (.validator.field) = {
inline bool UpdateNetworkParameter::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool UpdateNetworkParameter::has_changes() const {
  return _internal_has_changes();
}
inline const ::vega::NetworkParameter& UpdateNetworkParameter::_internal_changes() const {
  const ::vega::NetworkParameter* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::NetworkParameter&>(
      ::vega::_NetworkParameter_default_instance_);
}
inline const ::vega::NetworkParameter& UpdateNetworkParameter::changes() const {
  // @@protoc_insertion_point(field_get:vega.UpdateNetworkParameter.changes)
  return _internal_changes();
}
inline void UpdateNetworkParameter::unsafe_arena_set_allocated_changes(
    ::vega::NetworkParameter* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.UpdateNetworkParameter.changes)
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::release_changes() {

  ::vega::NetworkParameter* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.UpdateNetworkParameter.changes)

  ::vega::NetworkParameter* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::NetworkParameter>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::NetworkParameter* UpdateNetworkParameter::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.UpdateNetworkParameter.changes)
  return _internal_mutable_changes();
}
inline void UpdateNetworkParameter::set_allocated_changes(::vega::NetworkParameter* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes)->GetArena();
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.UpdateNetworkParameter.changes)
}

// -------------------------------------------------------------------

// NewAsset

// .vega.AssetSource changes = 1 [json_name = "changes", (.validator.field) = {
inline bool NewAsset::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool NewAsset::has_changes() const {
  return _internal_has_changes();
}
inline const ::vega::AssetSource& NewAsset::_internal_changes() const {
  const ::vega::AssetSource* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::AssetSource&>(
      ::vega::_AssetSource_default_instance_);
}
inline const ::vega::AssetSource& NewAsset::changes() const {
  // @@protoc_insertion_point(field_get:vega.NewAsset.changes)
  return _internal_changes();
}
inline void NewAsset::unsafe_arena_set_allocated_changes(
    ::vega::AssetSource* changes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.NewAsset.changes)
}
inline ::vega::AssetSource* NewAsset::release_changes() {

  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::AssetSource* NewAsset::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:vega.NewAsset.changes)

  ::vega::AssetSource* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::vega::AssetSource* NewAsset::_internal_mutable_changes() {

  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AssetSource>(GetArena());
    changes_ = p;
  }
  return changes_;
}
inline ::vega::AssetSource* NewAsset::mutable_changes() {
  // @@protoc_insertion_point(field_mutable:vega.NewAsset.changes)
  return _internal_mutable_changes();
}
inline void NewAsset::set_allocated_changes(::vega::AssetSource* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes)->GetArena();
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }

  } else {

  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:vega.NewAsset.changes)
}

// -------------------------------------------------------------------

// ProposalTerms

// int64 closing_timestamp = 1 [json_name = "closingTimestamp", (.validator.field) = {
inline void ProposalTerms::clear_closing_timestamp() {
  closing_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_closing_timestamp() const {
  return closing_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::closing_timestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.closing_timestamp)
  return _internal_closing_timestamp();
}
inline void ProposalTerms::_internal_set_closing_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  closing_timestamp_ = value;
}
inline void ProposalTerms::set_closing_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_closing_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.closing_timestamp)
}

// int64 enactment_timestamp = 2 [json_name = "enactmentTimestamp", (.validator.field) = {
inline void ProposalTerms::clear_enactment_timestamp() {
  enactment_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_enactment_timestamp() const {
  return enactment_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::enactment_timestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.enactment_timestamp)
  return _internal_enactment_timestamp();
}
inline void ProposalTerms::_internal_set_enactment_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  enactment_timestamp_ = value;
}
inline void ProposalTerms::set_enactment_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_enactment_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.enactment_timestamp)
}

// int64 validation_timestamp = 3 [json_name = "validationTimestamp"];
inline void ProposalTerms::clear_validation_timestamp() {
  validation_timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::_internal_validation_timestamp() const {
  return validation_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProposalTerms::validation_timestamp() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.validation_timestamp)
  return _internal_validation_timestamp();
}
inline void ProposalTerms::_internal_set_validation_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  validation_timestamp_ = value;
}
inline void ProposalTerms::set_validation_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_validation_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.ProposalTerms.validation_timestamp)
}

// .vega.UpdateMarket update_market = 101 [json_name = "updateMarket"];
inline bool ProposalTerms::_internal_has_update_market() const {
  return change_case() == kUpdateMarket;
}
inline bool ProposalTerms::has_update_market() const {
  return _internal_has_update_market();
}
inline void ProposalTerms::set_has_update_market() {
  _oneof_case_[0] = kUpdateMarket;
}
inline void ProposalTerms::clear_update_market() {
  if (_internal_has_update_market()) {
    if (GetArena() == nullptr) {
      delete change_.update_market_;
    }
    clear_has_change();
  }
}
inline ::vega::UpdateMarket* ProposalTerms::release_update_market() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.update_market)
  if (_internal_has_update_market()) {
    clear_has_change();
      ::vega::UpdateMarket* temp = change_.update_market_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.update_market_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateMarket& ProposalTerms::_internal_update_market() const {
  return _internal_has_update_market()
      ? *change_.update_market_
      : reinterpret_cast< ::vega::UpdateMarket&>(::vega::_UpdateMarket_default_instance_);
}
inline const ::vega::UpdateMarket& ProposalTerms::update_market() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.update_market)
  return _internal_update_market();
}
inline ::vega::UpdateMarket* ProposalTerms::unsafe_arena_release_update_market() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.update_market)
  if (_internal_has_update_market()) {
    clear_has_change();
    ::vega::UpdateMarket* temp = change_.update_market_;
    change_.update_market_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_update_market(::vega::UpdateMarket* update_market) {
  clear_change();
  if (update_market) {
    set_has_update_market();
    change_.update_market_ = update_market;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.update_market)
}
inline ::vega::UpdateMarket* ProposalTerms::_internal_mutable_update_market() {
  if (!_internal_has_update_market()) {
    clear_change();
    set_has_update_market();
    change_.update_market_ = CreateMaybeMessage< ::vega::UpdateMarket >(GetArena());
  }
  return change_.update_market_;
}
inline ::vega::UpdateMarket* ProposalTerms::mutable_update_market() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.update_market)
  return _internal_mutable_update_market();
}

// .vega.NewMarket new_market = 102 [json_name = "newMarket"];
inline bool ProposalTerms::_internal_has_new_market() const {
  return change_case() == kNewMarket;
}
inline bool ProposalTerms::has_new_market() const {
  return _internal_has_new_market();
}
inline void ProposalTerms::set_has_new_market() {
  _oneof_case_[0] = kNewMarket;
}
inline void ProposalTerms::clear_new_market() {
  if (_internal_has_new_market()) {
    if (GetArena() == nullptr) {
      delete change_.new_market_;
    }
    clear_has_change();
  }
}
inline ::vega::NewMarket* ProposalTerms::release_new_market() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.new_market)
  if (_internal_has_new_market()) {
    clear_has_change();
      ::vega::NewMarket* temp = change_.new_market_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.new_market_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewMarket& ProposalTerms::_internal_new_market() const {
  return _internal_has_new_market()
      ? *change_.new_market_
      : reinterpret_cast< ::vega::NewMarket&>(::vega::_NewMarket_default_instance_);
}
inline const ::vega::NewMarket& ProposalTerms::new_market() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.new_market)
  return _internal_new_market();
}
inline ::vega::NewMarket* ProposalTerms::unsafe_arena_release_new_market() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.new_market)
  if (_internal_has_new_market()) {
    clear_has_change();
    ::vega::NewMarket* temp = change_.new_market_;
    change_.new_market_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_new_market(::vega::NewMarket* new_market) {
  clear_change();
  if (new_market) {
    set_has_new_market();
    change_.new_market_ = new_market;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.new_market)
}
inline ::vega::NewMarket* ProposalTerms::_internal_mutable_new_market() {
  if (!_internal_has_new_market()) {
    clear_change();
    set_has_new_market();
    change_.new_market_ = CreateMaybeMessage< ::vega::NewMarket >(GetArena());
  }
  return change_.new_market_;
}
inline ::vega::NewMarket* ProposalTerms::mutable_new_market() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.new_market)
  return _internal_mutable_new_market();
}

// .vega.UpdateNetworkParameter update_network_parameter = 103 [json_name = "updateNetworkParameter"];
inline bool ProposalTerms::_internal_has_update_network_parameter() const {
  return change_case() == kUpdateNetworkParameter;
}
inline bool ProposalTerms::has_update_network_parameter() const {
  return _internal_has_update_network_parameter();
}
inline void ProposalTerms::set_has_update_network_parameter() {
  _oneof_case_[0] = kUpdateNetworkParameter;
}
inline void ProposalTerms::clear_update_network_parameter() {
  if (_internal_has_update_network_parameter()) {
    if (GetArena() == nullptr) {
      delete change_.update_network_parameter_;
    }
    clear_has_change();
  }
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::release_update_network_parameter() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.update_network_parameter)
  if (_internal_has_update_network_parameter()) {
    clear_has_change();
      ::vega::UpdateNetworkParameter* temp = change_.update_network_parameter_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.update_network_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::UpdateNetworkParameter& ProposalTerms::_internal_update_network_parameter() const {
  return _internal_has_update_network_parameter()
      ? *change_.update_network_parameter_
      : reinterpret_cast< ::vega::UpdateNetworkParameter&>(::vega::_UpdateNetworkParameter_default_instance_);
}
inline const ::vega::UpdateNetworkParameter& ProposalTerms::update_network_parameter() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.update_network_parameter)
  return _internal_update_network_parameter();
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::unsafe_arena_release_update_network_parameter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.update_network_parameter)
  if (_internal_has_update_network_parameter()) {
    clear_has_change();
    ::vega::UpdateNetworkParameter* temp = change_.update_network_parameter_;
    change_.update_network_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_update_network_parameter(::vega::UpdateNetworkParameter* update_network_parameter) {
  clear_change();
  if (update_network_parameter) {
    set_has_update_network_parameter();
    change_.update_network_parameter_ = update_network_parameter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.update_network_parameter)
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::_internal_mutable_update_network_parameter() {
  if (!_internal_has_update_network_parameter()) {
    clear_change();
    set_has_update_network_parameter();
    change_.update_network_parameter_ = CreateMaybeMessage< ::vega::UpdateNetworkParameter >(GetArena());
  }
  return change_.update_network_parameter_;
}
inline ::vega::UpdateNetworkParameter* ProposalTerms::mutable_update_network_parameter() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.update_network_parameter)
  return _internal_mutable_update_network_parameter();
}

// .vega.NewAsset new_asset = 104 [json_name = "newAsset"];
inline bool ProposalTerms::_internal_has_new_asset() const {
  return change_case() == kNewAsset;
}
inline bool ProposalTerms::has_new_asset() const {
  return _internal_has_new_asset();
}
inline void ProposalTerms::set_has_new_asset() {
  _oneof_case_[0] = kNewAsset;
}
inline void ProposalTerms::clear_new_asset() {
  if (_internal_has_new_asset()) {
    if (GetArena() == nullptr) {
      delete change_.new_asset_;
    }
    clear_has_change();
  }
}
inline ::vega::NewAsset* ProposalTerms::release_new_asset() {
  // @@protoc_insertion_point(field_release:vega.ProposalTerms.new_asset)
  if (_internal_has_new_asset()) {
    clear_has_change();
      ::vega::NewAsset* temp = change_.new_asset_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    change_.new_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::NewAsset& ProposalTerms::_internal_new_asset() const {
  return _internal_has_new_asset()
      ? *change_.new_asset_
      : reinterpret_cast< ::vega::NewAsset&>(::vega::_NewAsset_default_instance_);
}
inline const ::vega::NewAsset& ProposalTerms::new_asset() const {
  // @@protoc_insertion_point(field_get:vega.ProposalTerms.new_asset)
  return _internal_new_asset();
}
inline ::vega::NewAsset* ProposalTerms::unsafe_arena_release_new_asset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.ProposalTerms.new_asset)
  if (_internal_has_new_asset()) {
    clear_has_change();
    ::vega::NewAsset* temp = change_.new_asset_;
    change_.new_asset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProposalTerms::unsafe_arena_set_allocated_new_asset(::vega::NewAsset* new_asset) {
  clear_change();
  if (new_asset) {
    set_has_new_asset();
    change_.new_asset_ = new_asset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.ProposalTerms.new_asset)
}
inline ::vega::NewAsset* ProposalTerms::_internal_mutable_new_asset() {
  if (!_internal_has_new_asset()) {
    clear_change();
    set_has_new_asset();
    change_.new_asset_ = CreateMaybeMessage< ::vega::NewAsset >(GetArena());
  }
  return change_.new_asset_;
}
inline ::vega::NewAsset* ProposalTerms::mutable_new_asset() {
  // @@protoc_insertion_point(field_mutable:vega.ProposalTerms.new_asset)
  return _internal_mutable_new_asset();
}

inline bool ProposalTerms::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void ProposalTerms::clear_has_change() {
  _oneof_case_[0] = CHANGE_NOT_SET;
}
inline ProposalTerms::ChangeCase ProposalTerms::change_case() const {
  return ProposalTerms::ChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GovernanceData

// .vega.Proposal proposal = 1 [json_name = "proposal"];
inline bool GovernanceData::_internal_has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline bool GovernanceData::has_proposal() const {
  return _internal_has_proposal();
}
inline void GovernanceData::clear_proposal() {
  if (GetArena() == nullptr && proposal_ != nullptr) {
    delete proposal_;
  }
  proposal_ = nullptr;
}
inline const ::vega::Proposal& GovernanceData::_internal_proposal() const {
  const ::vega::Proposal* p = proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Proposal&>(
      ::vega::_Proposal_default_instance_);
}
inline const ::vega::Proposal& GovernanceData::proposal() const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.proposal)
  return _internal_proposal();
}
inline void GovernanceData::unsafe_arena_set_allocated_proposal(
    ::vega::Proposal* proposal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  proposal_ = proposal;
  if (proposal) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.GovernanceData.proposal)
}
inline ::vega::Proposal* GovernanceData::release_proposal() {

  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Proposal* GovernanceData::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:vega.GovernanceData.proposal)

  ::vega::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::vega::Proposal* GovernanceData::_internal_mutable_proposal() {

  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Proposal>(GetArena());
    proposal_ = p;
  }
  return proposal_;
}
inline ::vega::Proposal* GovernanceData::mutable_proposal() {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.proposal)
  return _internal_mutable_proposal();
}
inline void GovernanceData::set_allocated_proposal(::vega::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete proposal_;
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(proposal);
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }

  } else {

  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:vega.GovernanceData.proposal)
}

// repeated .vega.Vote yes = 2 [json_name = "yes"];
inline int GovernanceData::_internal_yes_size() const {
  return yes_.size();
}
inline int GovernanceData::yes_size() const {
  return _internal_yes_size();
}
inline void GovernanceData::clear_yes() {
  yes_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_yes(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.yes)
  return yes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_yes() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.yes)
  return &yes_;
}
inline const ::vega::Vote& GovernanceData::_internal_yes(int index) const {
  return yes_.Get(index);
}
inline const ::vega::Vote& GovernanceData::yes(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.yes)
  return _internal_yes(index);
}
inline ::vega::Vote* GovernanceData::_internal_add_yes() {
  return yes_.Add();
}
inline ::vega::Vote* GovernanceData::add_yes() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.yes)
  return _internal_add_yes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
GovernanceData::yes() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.yes)
  return yes_;
}

// repeated .vega.Vote no = 3 [json_name = "no"];
inline int GovernanceData::_internal_no_size() const {
  return no_.size();
}
inline int GovernanceData::no_size() const {
  return _internal_no_size();
}
inline void GovernanceData::clear_no() {
  no_.Clear();
}
inline ::vega::Vote* GovernanceData::mutable_no(int index) {
  // @@protoc_insertion_point(field_mutable:vega.GovernanceData.no)
  return no_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >*
GovernanceData::mutable_no() {
  // @@protoc_insertion_point(field_mutable_list:vega.GovernanceData.no)
  return &no_;
}
inline const ::vega::Vote& GovernanceData::_internal_no(int index) const {
  return no_.Get(index);
}
inline const ::vega::Vote& GovernanceData::no(int index) const {
  // @@protoc_insertion_point(field_get:vega.GovernanceData.no)
  return _internal_no(index);
}
inline ::vega::Vote* GovernanceData::_internal_add_no() {
  return no_.Add();
}
inline ::vega::Vote* GovernanceData::add_no() {
  // @@protoc_insertion_point(field_add:vega.GovernanceData.no)
  return _internal_add_no();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::Vote >&
GovernanceData::no() const {
  // @@protoc_insertion_point(field_list:vega.GovernanceData.no)
  return no_;
}

// map<string, .vega.Vote> yes_party = 4 [json_name = "yesParty"];
inline int GovernanceData::_internal_yes_party_size() const {
  return yes_party_.size();
}
inline int GovernanceData::yes_party_size() const {
  return _internal_yes_party_size();
}
inline void GovernanceData::clear_yes_party() {
  yes_party_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::_internal_yes_party() const {
  return yes_party_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::yes_party() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.yes_party)
  return _internal_yes_party();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::_internal_mutable_yes_party() {
  return yes_party_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::mutable_yes_party() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.yes_party)
  return _internal_mutable_yes_party();
}

// map<string, .vega.Vote> no_party = 5 [json_name = "noParty"];
inline int GovernanceData::_internal_no_party_size() const {
  return no_party_.size();
}
inline int GovernanceData::no_party_size() const {
  return _internal_no_party_size();
}
inline void GovernanceData::clear_no_party() {
  no_party_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::_internal_no_party() const {
  return no_party_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >&
GovernanceData::no_party() const {
  // @@protoc_insertion_point(field_map:vega.GovernanceData.no_party)
  return _internal_no_party();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::_internal_mutable_no_party() {
  return no_party_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::vega::Vote >*
GovernanceData::mutable_no_party() {
  // @@protoc_insertion_point(field_mutable_map:vega.GovernanceData.no_party)
  return _internal_mutable_no_party();
}

// -------------------------------------------------------------------

// Proposal

// string id = 1 [json_name = "id"];
inline void Proposal::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Proposal::id() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.id)
  return _internal_id();
}
inline void Proposal::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.id)
}
inline std::string* Proposal::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.id)
  return _internal_mutable_id();
}
inline const std::string& Proposal::_internal_id() const {
  return id_.Get();
}
inline void Proposal::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.id)
}
inline void Proposal::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.id)
}
inline void Proposal::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.id)
}
inline std::string* Proposal::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_id() {
  // @@protoc_insertion_point(field_release:vega.Proposal.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.id)
}

// string reference = 2 [json_name = "reference"];
inline void Proposal::clear_reference() {
  reference_.ClearToEmpty();
}
inline const std::string& Proposal::reference() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reference)
  return _internal_reference();
}
inline void Proposal::set_reference(const std::string& value) {
  _internal_set_reference(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reference)
}
inline std::string* Proposal::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.reference)
  return _internal_mutable_reference();
}
inline const std::string& Proposal::_internal_reference() const {
  return reference_.Get();
}
inline void Proposal::_internal_set_reference(const std::string& value) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_reference(std::string&& value) {

  reference_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.reference)
}
inline void Proposal::set_reference(const char* value,
    size_t size) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.reference)
}
inline std::string* Proposal::_internal_mutable_reference() {

  return reference_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_reference() {
  // @@protoc_insertion_point(field_release:vega.Proposal.reference)
  return reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_reference(std::string* reference) {
  if (reference != nullptr) {

  } else {

  }
  reference_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.reference)
}

// string party_id = 3 [json_name = "partyId", (.validator.field) = {
inline void Proposal::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& Proposal::party_id() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.party_id)
  return _internal_party_id();
}
inline void Proposal::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.party_id)
}
inline std::string* Proposal::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& Proposal::_internal_party_id() const {
  return party_id_.Get();
}
inline void Proposal::_internal_set_party_id(const std::string& value) {

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Proposal::set_party_id(std::string&& value) {

  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Proposal.party_id)
}
inline void Proposal::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Proposal.party_id)
}
inline void Proposal::set_party_id(const char* value,
    size_t size) {

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Proposal.party_id)
}
inline std::string* Proposal::_internal_mutable_party_id() {

  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Proposal::release_party_id() {
  // @@protoc_insertion_point(field_release:vega.Proposal.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Proposal::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {

  } else {

  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.party_id)
}

// .vega.Proposal.State state = 4 [json_name = "state", (.validator.field) = {
inline void Proposal::clear_state() {
  state_ = 0;
}
inline ::vega::Proposal_State Proposal::_internal_state() const {
  return static_cast< ::vega::Proposal_State >(state_);
}
inline ::vega::Proposal_State Proposal::state() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.state)
  return _internal_state();
}
inline void Proposal::_internal_set_state(::vega::Proposal_State value) {

  state_ = value;
}
inline void Proposal::set_state(::vega::Proposal_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.state)
}

// int64 timestamp = 5 [json_name = "timestamp"];
inline void Proposal::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Proposal::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Proposal::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.timestamp)
  return _internal_timestamp();
}
inline void Proposal::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  timestamp_ = value;
}
inline void Proposal::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.timestamp)
}

// .vega.ProposalTerms terms = 6 [json_name = "terms", (.validator.field) = {
inline bool Proposal::_internal_has_terms() const {
  return this != internal_default_instance() && terms_ != nullptr;
}
inline bool Proposal::has_terms() const {
  return _internal_has_terms();
}
inline void Proposal::clear_terms() {
  if (GetArena() == nullptr && terms_ != nullptr) {
    delete terms_;
  }
  terms_ = nullptr;
}
inline const ::vega::ProposalTerms& Proposal::_internal_terms() const {
  const ::vega::ProposalTerms* p = terms_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::ProposalTerms&>(
      ::vega::_ProposalTerms_default_instance_);
}
inline const ::vega::ProposalTerms& Proposal::terms() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.terms)
  return _internal_terms();
}
inline void Proposal::unsafe_arena_set_allocated_terms(
    ::vega::ProposalTerms* terms) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(terms_);
  }
  terms_ = terms;
  if (terms) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Proposal.terms)
}
inline ::vega::ProposalTerms* Proposal::release_terms() {

  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::ProposalTerms* Proposal::unsafe_arena_release_terms() {
  // @@protoc_insertion_point(field_release:vega.Proposal.terms)

  ::vega::ProposalTerms* temp = terms_;
  terms_ = nullptr;
  return temp;
}
inline ::vega::ProposalTerms* Proposal::_internal_mutable_terms() {

  if (terms_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ProposalTerms>(GetArena());
    terms_ = p;
  }
  return terms_;
}
inline ::vega::ProposalTerms* Proposal::mutable_terms() {
  // @@protoc_insertion_point(field_mutable:vega.Proposal.terms)
  return _internal_mutable_terms();
}
inline void Proposal::set_allocated_terms(::vega::ProposalTerms* terms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete terms_;
  }
  if (terms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(terms);
    if (message_arena != submessage_arena) {
      terms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terms, submessage_arena);
    }

  } else {

  }
  terms_ = terms;
  // @@protoc_insertion_point(field_set_allocated:vega.Proposal.terms)
}

// .vega.ProposalError reason = 7 [json_name = "reason"];
inline void Proposal::clear_reason() {
  reason_ = 0;
}
inline ::vega::ProposalError Proposal::_internal_reason() const {
  return static_cast< ::vega::ProposalError >(reason_);
}
inline ::vega::ProposalError Proposal::reason() const {
  // @@protoc_insertion_point(field_get:vega.Proposal.reason)
  return _internal_reason();
}
inline void Proposal::_internal_set_reason(::vega::ProposalError value) {

  reason_ = value;
}
inline void Proposal::set_reason(::vega::ProposalError value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:vega.Proposal.reason)
}

// -------------------------------------------------------------------

// Vote

// string party_id = 1 [json_name = "partyId", (.validator.field) = {
inline void Vote::clear_party_id() {
  party_id_.ClearToEmpty();
}
inline const std::string& Vote::party_id() const {
  // @@protoc_insertion_point(field_get:vega.Vote.party_id)
  return _internal_party_id();
}
inline void Vote::set_party_id(const std::string& value) {
  _internal_set_party_id(value);
  // @@protoc_insertion_point(field_set:vega.Vote.party_id)
}
inline std::string* Vote::mutable_party_id() {
  // @@protoc_insertion_point(field_mutable:vega.Vote.party_id)
  return _internal_mutable_party_id();
}
inline const std::string& Vote::_internal_party_id() const {
  return party_id_.Get();
}
inline void Vote::_internal_set_party_id(const std::string& value) {

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Vote::set_party_id(std::string&& value) {

  party_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.party_id)
}
inline void Vote::set_party_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Vote.party_id)
}
inline void Vote::set_party_id(const char* value,
    size_t size) {

  party_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.party_id)
}
inline std::string* Vote::_internal_mutable_party_id() {

  return party_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Vote::release_party_id() {
  // @@protoc_insertion_point(field_release:vega.Vote.party_id)
  return party_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Vote::set_allocated_party_id(std::string* party_id) {
  if (party_id != nullptr) {

  } else {

  }
  party_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), party_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.party_id)
}

// .vega.Vote.Value value = 2 [json_name = "value", (.validator.field) = {
inline void Vote::clear_value() {
  value_ = 0;
}
inline ::vega::Vote_Value Vote::_internal_value() const {
  return static_cast< ::vega::Vote_Value >(value_);
}
inline ::vega::Vote_Value Vote::value() const {
  // @@protoc_insertion_point(field_get:vega.Vote.value)
  return _internal_value();
}
inline void Vote::_internal_set_value(::vega::Vote_Value value) {

  value_ = value;
}
inline void Vote::set_value(::vega::Vote_Value value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:vega.Vote.value)
}

// string proposal_id = 3 [json_name = "proposalId", (.validator.field) = {
inline void Vote::clear_proposal_id() {
  proposal_id_.ClearToEmpty();
}
inline const std::string& Vote::proposal_id() const {
  // @@protoc_insertion_point(field_get:vega.Vote.proposal_id)
  return _internal_proposal_id();
}
inline void Vote::set_proposal_id(const std::string& value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:vega.Vote.proposal_id)
}
inline std::string* Vote::mutable_proposal_id() {
  // @@protoc_insertion_point(field_mutable:vega.Vote.proposal_id)
  return _internal_mutable_proposal_id();
}
inline const std::string& Vote::_internal_proposal_id() const {
  return proposal_id_.Get();
}
inline void Vote::_internal_set_proposal_id(const std::string& value) {

  proposal_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Vote::set_proposal_id(std::string&& value) {

  proposal_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.proposal_id)
}
inline void Vote::set_proposal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  proposal_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Vote.proposal_id)
}
inline void Vote::set_proposal_id(const char* value,
    size_t size) {

  proposal_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.proposal_id)
}
inline std::string* Vote::_internal_mutable_proposal_id() {

  return proposal_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Vote::release_proposal_id() {
  // @@protoc_insertion_point(field_release:vega.Vote.proposal_id)
  return proposal_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Vote::set_allocated_proposal_id(std::string* proposal_id) {
  if (proposal_id != nullptr) {

  } else {

  }
  proposal_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proposal_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.proposal_id)
}

// int64 timestamp = 4 [json_name = "timestamp"];
inline void Vote::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Vote::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Vote::timestamp() const {
  // @@protoc_insertion_point(field_get:vega.Vote.timestamp)
  return _internal_timestamp();
}
inline void Vote::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {

  timestamp_ = value;
}
inline void Vote::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:vega.Vote.timestamp)
}

// uint64 total_governance_token_balance = 5 [json_name = "totalGovernanceTokenBalance"];
inline void Vote::clear_total_governance_token_balance() {
  total_governance_token_balance_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Vote::_internal_total_governance_token_balance() const {
  return total_governance_token_balance_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Vote::total_governance_token_balance() const {
  // @@protoc_insertion_point(field_get:vega.Vote.total_governance_token_balance)
  return _internal_total_governance_token_balance();
}
inline void Vote::_internal_set_total_governance_token_balance(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  total_governance_token_balance_ = value;
}
inline void Vote::set_total_governance_token_balance(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_governance_token_balance(value);
  // @@protoc_insertion_point(field_set:vega.Vote.total_governance_token_balance)
}

// string total_governance_token_weight = 6 [json_name = "totalGovernanceTokenWeight"];
inline void Vote::clear_total_governance_token_weight() {
  total_governance_token_weight_.ClearToEmpty();
}
inline const std::string& Vote::total_governance_token_weight() const {
  // @@protoc_insertion_point(field_get:vega.Vote.total_governance_token_weight)
  return _internal_total_governance_token_weight();
}
inline void Vote::set_total_governance_token_weight(const std::string& value) {
  _internal_set_total_governance_token_weight(value);
  // @@protoc_insertion_point(field_set:vega.Vote.total_governance_token_weight)
}
inline std::string* Vote::mutable_total_governance_token_weight() {
  // @@protoc_insertion_point(field_mutable:vega.Vote.total_governance_token_weight)
  return _internal_mutable_total_governance_token_weight();
}
inline const std::string& Vote::_internal_total_governance_token_weight() const {
  return total_governance_token_weight_.Get();
}
inline void Vote::_internal_set_total_governance_token_weight(const std::string& value) {

  total_governance_token_weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Vote::set_total_governance_token_weight(std::string&& value) {

  total_governance_token_weight_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Vote.total_governance_token_weight)
}
inline void Vote::set_total_governance_token_weight(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  total_governance_token_weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Vote.total_governance_token_weight)
}
inline void Vote::set_total_governance_token_weight(const char* value,
    size_t size) {

  total_governance_token_weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Vote.total_governance_token_weight)
}
inline std::string* Vote::_internal_mutable_total_governance_token_weight() {

  return total_governance_token_weight_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Vote::release_total_governance_token_weight() {
  // @@protoc_insertion_point(field_release:vega.Vote.total_governance_token_weight)
  return total_governance_token_weight_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Vote::set_allocated_total_governance_token_weight(std::string* total_governance_token_weight) {
  if (total_governance_token_weight != nullptr) {

  } else {

  }
  total_governance_token_weight_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), total_governance_token_weight,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Vote.total_governance_token_weight)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vega::Proposal_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Proposal_State>() {
  return ::vega::Proposal_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Vote_Value> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Vote_Value>() {
  return ::vega::Vote_Value_descriptor();
}
template <> struct is_proto_enum< ::vega::ProposalError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::ProposalError>() {
  return ::vega::ProposalError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_governance_2eproto
