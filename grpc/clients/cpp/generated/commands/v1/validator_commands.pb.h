// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commands/v1/validator_commands.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_commands_2fv1_2fvalidator_5fcommands_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_commands_2fv1_2fvalidator_5fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "chain_events.pb.h"
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_commands_2fv1_2fvalidator_5fcommands_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_commands_2fv1_2fvalidator_5fcommands_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto;
namespace vega {
namespace commands {
namespace v1 {
class ChainEvent;
class ChainEventDefaultTypeInternal;
extern ChainEventDefaultTypeInternal _ChainEvent_default_instance_;
class NodeRegistration;
class NodeRegistrationDefaultTypeInternal;
extern NodeRegistrationDefaultTypeInternal _NodeRegistration_default_instance_;
class NodeSignature;
class NodeSignatureDefaultTypeInternal;
extern NodeSignatureDefaultTypeInternal _NodeSignature_default_instance_;
class NodeVote;
class NodeVoteDefaultTypeInternal;
extern NodeVoteDefaultTypeInternal _NodeVote_default_instance_;
}  // namespace v1
}  // namespace commands
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::commands::v1::ChainEvent* Arena::CreateMaybeMessage<::vega::commands::v1::ChainEvent>(Arena*);
template<> ::vega::commands::v1::NodeRegistration* Arena::CreateMaybeMessage<::vega::commands::v1::NodeRegistration>(Arena*);
template<> ::vega::commands::v1::NodeSignature* Arena::CreateMaybeMessage<::vega::commands::v1::NodeSignature>(Arena*);
template<> ::vega::commands::v1::NodeVote* Arena::CreateMaybeMessage<::vega::commands::v1::NodeVote>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {
namespace commands {
namespace v1 {

enum NodeSignatureKind : int {
  NODE_SIGNATURE_KIND_UNSPECIFIED = 0,
  NODE_SIGNATURE_KIND_ASSET_NEW = 1,
  NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL = 2,
  NodeSignatureKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NodeSignatureKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NodeSignatureKind_IsValid(int value);
constexpr NodeSignatureKind NodeSignatureKind_MIN = NODE_SIGNATURE_KIND_UNSPECIFIED;
constexpr NodeSignatureKind NodeSignatureKind_MAX = NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL;
constexpr int NodeSignatureKind_ARRAYSIZE = NodeSignatureKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeSignatureKind_descriptor();
template<typename T>
inline const std::string& NodeSignatureKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeSignatureKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeSignatureKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeSignatureKind_descriptor(), enum_t_value);
}
inline bool NodeSignatureKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeSignatureKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeSignatureKind>(
    NodeSignatureKind_descriptor(), name, value);
}
// ===================================================================

class NodeRegistration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.commands.v1.NodeRegistration) */ {
 public:
  inline NodeRegistration() : NodeRegistration(nullptr) {}
  virtual ~NodeRegistration();

  NodeRegistration(const NodeRegistration& from);
  NodeRegistration(NodeRegistration&& from) noexcept
    : NodeRegistration() {
    *this = ::std::move(from);
  }

  inline NodeRegistration& operator=(const NodeRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRegistration& operator=(NodeRegistration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeRegistration& default_instance();

  static inline const NodeRegistration* internal_default_instance() {
    return reinterpret_cast<const NodeRegistration*>(
               &_NodeRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeRegistration& a, NodeRegistration& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRegistration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRegistration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeRegistration* New() const final {
    return CreateMaybeMessage<NodeRegistration>(nullptr);
  }

  NodeRegistration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeRegistration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeRegistration& from);
  void MergeFrom(const NodeRegistration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRegistration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.commands.v1.NodeRegistration";
  }
  protected:
  explicit NodeRegistration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto);
    return ::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVegaPubKeyFieldNumber = 1,
    kEthereumAddressFieldNumber = 2,
    kChainPubKeyFieldNumber = 3,
    kInfoUrlFieldNumber = 4,
    kCountryFieldNumber = 5,
  };
  // string vega_pub_key = 1 [json_name = "vegaPubKey", (.validator.field) = {
  void clear_vega_pub_key();
  const std::string& vega_pub_key() const;
  void set_vega_pub_key(const std::string& value);
  void set_vega_pub_key(std::string&& value);
  void set_vega_pub_key(const char* value);
  void set_vega_pub_key(const char* value, size_t size);
  std::string* mutable_vega_pub_key();
  std::string* release_vega_pub_key();
  void set_allocated_vega_pub_key(std::string* vega_pub_key);
  private:
  const std::string& _internal_vega_pub_key() const;
  void _internal_set_vega_pub_key(const std::string& value);
  std::string* _internal_mutable_vega_pub_key();
  public:

  // string ethereum_address = 2 [json_name = "ethereumAddress", (.validator.field) = {
  void clear_ethereum_address();
  const std::string& ethereum_address() const;
  void set_ethereum_address(const std::string& value);
  void set_ethereum_address(std::string&& value);
  void set_ethereum_address(const char* value);
  void set_ethereum_address(const char* value, size_t size);
  std::string* mutable_ethereum_address();
  std::string* release_ethereum_address();
  void set_allocated_ethereum_address(std::string* ethereum_address);
  private:
  const std::string& _internal_ethereum_address() const;
  void _internal_set_ethereum_address(const std::string& value);
  std::string* _internal_mutable_ethereum_address();
  public:

  // string chain_pub_key = 3 [json_name = "chainPubKey", (.validator.field) = {
  void clear_chain_pub_key();
  const std::string& chain_pub_key() const;
  void set_chain_pub_key(const std::string& value);
  void set_chain_pub_key(std::string&& value);
  void set_chain_pub_key(const char* value);
  void set_chain_pub_key(const char* value, size_t size);
  std::string* mutable_chain_pub_key();
  std::string* release_chain_pub_key();
  void set_allocated_chain_pub_key(std::string* chain_pub_key);
  private:
  const std::string& _internal_chain_pub_key() const;
  void _internal_set_chain_pub_key(const std::string& value);
  std::string* _internal_mutable_chain_pub_key();
  public:

  // string info_url = 4 [json_name = "infoUrl", (.validator.field) = {
  void clear_info_url();
  const std::string& info_url() const;
  void set_info_url(const std::string& value);
  void set_info_url(std::string&& value);
  void set_info_url(const char* value);
  void set_info_url(const char* value, size_t size);
  std::string* mutable_info_url();
  std::string* release_info_url();
  void set_allocated_info_url(std::string* info_url);
  private:
  const std::string& _internal_info_url() const;
  void _internal_set_info_url(const std::string& value);
  std::string* _internal_mutable_info_url();
  public:

  // string country = 5 [json_name = "country", (.validator.field) = {
  void clear_country();
  const std::string& country() const;
  void set_country(const std::string& value);
  void set_country(std::string&& value);
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  std::string* mutable_country();
  std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // @@protoc_insertion_point(class_scope:vega.commands.v1.NodeRegistration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vega_pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ethereum_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commands_2fv1_2fvalidator_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class NodeVote PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.commands.v1.NodeVote) */ {
 public:
  inline NodeVote() : NodeVote(nullptr) {}
  virtual ~NodeVote();

  NodeVote(const NodeVote& from);
  NodeVote(NodeVote&& from) noexcept
    : NodeVote() {
    *this = ::std::move(from);
  }

  inline NodeVote& operator=(const NodeVote& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeVote& operator=(NodeVote&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeVote& default_instance();

  static inline const NodeVote* internal_default_instance() {
    return reinterpret_cast<const NodeVote*>(
               &_NodeVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeVote& a, NodeVote& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeVote* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeVote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeVote* New() const final {
    return CreateMaybeMessage<NodeVote>(nullptr);
  }

  NodeVote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeVote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeVote& from);
  void MergeFrom(const NodeVote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeVote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.commands.v1.NodeVote";
  }
  protected:
  explicit NodeVote(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto);
    return ::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kReferenceFieldNumber = 2,
  };
  // bytes pub_key = 1 [json_name = "pubKey", (.validator.field) = {
  void clear_pub_key();
  const std::string& pub_key() const;
  void set_pub_key(const std::string& value);
  void set_pub_key(std::string&& value);
  void set_pub_key(const char* value);
  void set_pub_key(const void* value, size_t size);
  std::string* mutable_pub_key();
  std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // string reference = 2 [json_name = "reference", (.validator.field) = {
  void clear_reference();
  const std::string& reference() const;
  void set_reference(const std::string& value);
  void set_reference(std::string&& value);
  void set_reference(const char* value);
  void set_reference(const char* value, size_t size);
  std::string* mutable_reference();
  std::string* release_reference();
  void set_allocated_reference(std::string* reference);
  private:
  const std::string& _internal_reference() const;
  void _internal_set_reference(const std::string& value);
  std::string* _internal_mutable_reference();
  public:

  // @@protoc_insertion_point(class_scope:vega.commands.v1.NodeVote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commands_2fv1_2fvalidator_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class NodeSignature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.commands.v1.NodeSignature) */ {
 public:
  inline NodeSignature() : NodeSignature(nullptr) {}
  virtual ~NodeSignature();

  NodeSignature(const NodeSignature& from);
  NodeSignature(NodeSignature&& from) noexcept
    : NodeSignature() {
    *this = ::std::move(from);
  }

  inline NodeSignature& operator=(const NodeSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeSignature& operator=(NodeSignature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeSignature& default_instance();

  static inline const NodeSignature* internal_default_instance() {
    return reinterpret_cast<const NodeSignature*>(
               &_NodeSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeSignature& a, NodeSignature& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeSignature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeSignature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeSignature* New() const final {
    return CreateMaybeMessage<NodeSignature>(nullptr);
  }

  NodeSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeSignature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeSignature& from);
  void MergeFrom(const NodeSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeSignature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.commands.v1.NodeSignature";
  }
  protected:
  explicit NodeSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto);
    return ::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSigFieldNumber = 2,
    kKindFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes sig = 2 [json_name = "sig"];
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const void* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // .vega.commands.v1.NodeSignatureKind kind = 3 [json_name = "kind"];
  void clear_kind();
  ::vega::commands::v1::NodeSignatureKind kind() const;
  void set_kind(::vega::commands::v1::NodeSignatureKind value);
  private:
  ::vega::commands::v1::NodeSignatureKind _internal_kind() const;
  void _internal_set_kind(::vega::commands::v1::NodeSignatureKind value);
  public:

  // @@protoc_insertion_point(class_scope:vega.commands.v1.NodeSignature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_commands_2fv1_2fvalidator_5fcommands_2eproto;
};
// -------------------------------------------------------------------

class ChainEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.commands.v1.ChainEvent) */ {
 public:
  inline ChainEvent() : ChainEvent(nullptr) {}
  virtual ~ChainEvent();

  ChainEvent(const ChainEvent& from);
  ChainEvent(ChainEvent&& from) noexcept
    : ChainEvent() {
    *this = ::std::move(from);
  }

  inline ChainEvent& operator=(const ChainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainEvent& operator=(ChainEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChainEvent& default_instance();

  enum EventCase {
    kBuiltin = 1001,
    kErc20 = 1002,
    kBtc = 1003,
    kValidator = 1004,
    kStakingEvent = 1005,
    EVENT_NOT_SET = 0,
  };

  static inline const ChainEvent* internal_default_instance() {
    return reinterpret_cast<const ChainEvent*>(
               &_ChainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChainEvent& a, ChainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChainEvent* New() const final {
    return CreateMaybeMessage<ChainEvent>(nullptr);
  }

  ChainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChainEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChainEvent& from);
  void MergeFrom(const ChainEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.commands.v1.ChainEvent";
  }
  protected:
  explicit ChainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto);
    return ::descriptor_table_commands_2fv1_2fvalidator_5fcommands_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIdFieldNumber = 1,
    kNonceFieldNumber = 2,
    kBuiltinFieldNumber = 1001,
    kErc20FieldNumber = 1002,
    kBtcFieldNumber = 1003,
    kValidatorFieldNumber = 1004,
    kStakingEventFieldNumber = 1005,
  };
  // string tx_id = 1 [json_name = "txId"];
  void clear_tx_id();
  const std::string& tx_id() const;
  void set_tx_id(const std::string& value);
  void set_tx_id(std::string&& value);
  void set_tx_id(const char* value);
  void set_tx_id(const char* value, size_t size);
  std::string* mutable_tx_id();
  std::string* release_tx_id();
  void set_allocated_tx_id(std::string* tx_id);
  private:
  const std::string& _internal_tx_id() const;
  void _internal_set_tx_id(const std::string& value);
  std::string* _internal_mutable_tx_id();
  public:

  // uint64 nonce = 2 [json_name = "nonce"];
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.BuiltinAssetEvent builtin = 1001 [json_name = "builtin"];
  bool has_builtin() const;
  private:
  bool _internal_has_builtin() const;
  public:
  void clear_builtin();
  const ::vega::BuiltinAssetEvent& builtin() const;
  ::vega::BuiltinAssetEvent* release_builtin();
  ::vega::BuiltinAssetEvent* mutable_builtin();
  void set_allocated_builtin(::vega::BuiltinAssetEvent* builtin);
  private:
  const ::vega::BuiltinAssetEvent& _internal_builtin() const;
  ::vega::BuiltinAssetEvent* _internal_mutable_builtin();
  public:
  void unsafe_arena_set_allocated_builtin(
      ::vega::BuiltinAssetEvent* builtin);
  ::vega::BuiltinAssetEvent* unsafe_arena_release_builtin();

  // .vega.ERC20Event erc20 = 1002 [json_name = "erc20"];
  bool has_erc20() const;
  private:
  bool _internal_has_erc20() const;
  public:
  void clear_erc20();
  const ::vega::ERC20Event& erc20() const;
  ::vega::ERC20Event* release_erc20();
  ::vega::ERC20Event* mutable_erc20();
  void set_allocated_erc20(::vega::ERC20Event* erc20);
  private:
  const ::vega::ERC20Event& _internal_erc20() const;
  ::vega::ERC20Event* _internal_mutable_erc20();
  public:
  void unsafe_arena_set_allocated_erc20(
      ::vega::ERC20Event* erc20);
  ::vega::ERC20Event* unsafe_arena_release_erc20();

  // .vega.BTCEvent btc = 1003 [json_name = "btc"];
  bool has_btc() const;
  private:
  bool _internal_has_btc() const;
  public:
  void clear_btc();
  const ::vega::BTCEvent& btc() const;
  ::vega::BTCEvent* release_btc();
  ::vega::BTCEvent* mutable_btc();
  void set_allocated_btc(::vega::BTCEvent* btc);
  private:
  const ::vega::BTCEvent& _internal_btc() const;
  ::vega::BTCEvent* _internal_mutable_btc();
  public:
  void unsafe_arena_set_allocated_btc(
      ::vega::BTCEvent* btc);
  ::vega::BTCEvent* unsafe_arena_release_btc();

  // .vega.ValidatorEvent validator = 1004 [json_name = "validator"];
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::vega::ValidatorEvent& validator() const;
  ::vega::ValidatorEvent* release_validator();
  ::vega::ValidatorEvent* mutable_validator();
  void set_allocated_validator(::vega::ValidatorEvent* validator);
  private:
  const ::vega::ValidatorEvent& _internal_validator() const;
  ::vega::ValidatorEvent* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::vega::ValidatorEvent* validator);
  ::vega::ValidatorEvent* unsafe_arena_release_validator();

  // .vega.StakingEvent staking_event = 1005 [json_name = "stakingEvent"];
  bool has_staking_event() const;
  private:
  bool _internal_has_staking_event() const;
  public:
  void clear_staking_event();
  const ::vega::StakingEvent& staking_event() const;
  ::vega::StakingEvent* release_staking_event();
  ::vega::StakingEvent* mutable_staking_event();
  void set_allocated_staking_event(::vega::StakingEvent* staking_event);
  private:
  const ::vega::StakingEvent& _internal_staking_event() const;
  ::vega::StakingEvent* _internal_mutable_staking_event();
  public:
  void unsafe_arena_set_allocated_staking_event(
      ::vega::StakingEvent* staking_event);
  ::vega::StakingEvent* unsafe_arena_release_staking_event();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:vega.commands.v1.ChainEvent)
 private:
  class _Internal;
  void set_has_builtin();
  void set_has_erc20();
  void set_has_btc();
  void set_has_validator();
  void set_has_staking_event();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  union EventUnion {
    EventUnion() {}
    ::vega::BuiltinAssetEvent* builtin_;
    ::vega::ERC20Event* erc20_;
    ::vega::BTCEvent* btc_;
    ::vega::ValidatorEvent* validator_;
    ::vega::StakingEvent* staking_event_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_commands_2fv1_2fvalidator_5fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeRegistration

// string vega_pub_key = 1 [json_name = "vegaPubKey", (.validator.field) = {
inline void NodeRegistration::clear_vega_pub_key() {
  vega_pub_key_.ClearToEmpty();
}
inline const std::string& NodeRegistration::vega_pub_key() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeRegistration.vega_pub_key)
  return _internal_vega_pub_key();
}
inline void NodeRegistration::set_vega_pub_key(const std::string& value) {
  _internal_set_vega_pub_key(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeRegistration.vega_pub_key)
}
inline std::string* NodeRegistration::mutable_vega_pub_key() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeRegistration.vega_pub_key)
  return _internal_mutable_vega_pub_key();
}
inline const std::string& NodeRegistration::_internal_vega_pub_key() const {
  return vega_pub_key_.Get();
}
inline void NodeRegistration::_internal_set_vega_pub_key(const std::string& value) {

  vega_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeRegistration::set_vega_pub_key(std::string&& value) {

  vega_pub_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeRegistration.vega_pub_key)
}
inline void NodeRegistration::set_vega_pub_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  vega_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeRegistration.vega_pub_key)
}
inline void NodeRegistration::set_vega_pub_key(const char* value,
    size_t size) {

  vega_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeRegistration.vega_pub_key)
}
inline std::string* NodeRegistration::_internal_mutable_vega_pub_key() {

  return vega_pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeRegistration::release_vega_pub_key() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeRegistration.vega_pub_key)
  return vega_pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRegistration::set_allocated_vega_pub_key(std::string* vega_pub_key) {
  if (vega_pub_key != nullptr) {

  } else {

  }
  vega_pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vega_pub_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeRegistration.vega_pub_key)
}

// string ethereum_address = 2 [json_name = "ethereumAddress", (.validator.field) = {
inline void NodeRegistration::clear_ethereum_address() {
  ethereum_address_.ClearToEmpty();
}
inline const std::string& NodeRegistration::ethereum_address() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeRegistration.ethereum_address)
  return _internal_ethereum_address();
}
inline void NodeRegistration::set_ethereum_address(const std::string& value) {
  _internal_set_ethereum_address(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeRegistration.ethereum_address)
}
inline std::string* NodeRegistration::mutable_ethereum_address() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeRegistration.ethereum_address)
  return _internal_mutable_ethereum_address();
}
inline const std::string& NodeRegistration::_internal_ethereum_address() const {
  return ethereum_address_.Get();
}
inline void NodeRegistration::_internal_set_ethereum_address(const std::string& value) {

  ethereum_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeRegistration::set_ethereum_address(std::string&& value) {

  ethereum_address_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeRegistration.ethereum_address)
}
inline void NodeRegistration::set_ethereum_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  ethereum_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeRegistration.ethereum_address)
}
inline void NodeRegistration::set_ethereum_address(const char* value,
    size_t size) {

  ethereum_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeRegistration.ethereum_address)
}
inline std::string* NodeRegistration::_internal_mutable_ethereum_address() {

  return ethereum_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeRegistration::release_ethereum_address() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeRegistration.ethereum_address)
  return ethereum_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRegistration::set_allocated_ethereum_address(std::string* ethereum_address) {
  if (ethereum_address != nullptr) {

  } else {

  }
  ethereum_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ethereum_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeRegistration.ethereum_address)
}

// string chain_pub_key = 3 [json_name = "chainPubKey", (.validator.field) = {
inline void NodeRegistration::clear_chain_pub_key() {
  chain_pub_key_.ClearToEmpty();
}
inline const std::string& NodeRegistration::chain_pub_key() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeRegistration.chain_pub_key)
  return _internal_chain_pub_key();
}
inline void NodeRegistration::set_chain_pub_key(const std::string& value) {
  _internal_set_chain_pub_key(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeRegistration.chain_pub_key)
}
inline std::string* NodeRegistration::mutable_chain_pub_key() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeRegistration.chain_pub_key)
  return _internal_mutable_chain_pub_key();
}
inline const std::string& NodeRegistration::_internal_chain_pub_key() const {
  return chain_pub_key_.Get();
}
inline void NodeRegistration::_internal_set_chain_pub_key(const std::string& value) {

  chain_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeRegistration::set_chain_pub_key(std::string&& value) {

  chain_pub_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeRegistration.chain_pub_key)
}
inline void NodeRegistration::set_chain_pub_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  chain_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeRegistration.chain_pub_key)
}
inline void NodeRegistration::set_chain_pub_key(const char* value,
    size_t size) {

  chain_pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeRegistration.chain_pub_key)
}
inline std::string* NodeRegistration::_internal_mutable_chain_pub_key() {

  return chain_pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeRegistration::release_chain_pub_key() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeRegistration.chain_pub_key)
  return chain_pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRegistration::set_allocated_chain_pub_key(std::string* chain_pub_key) {
  if (chain_pub_key != nullptr) {

  } else {

  }
  chain_pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_pub_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeRegistration.chain_pub_key)
}

// string info_url = 4 [json_name = "infoUrl", (.validator.field) = {
inline void NodeRegistration::clear_info_url() {
  info_url_.ClearToEmpty();
}
inline const std::string& NodeRegistration::info_url() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeRegistration.info_url)
  return _internal_info_url();
}
inline void NodeRegistration::set_info_url(const std::string& value) {
  _internal_set_info_url(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeRegistration.info_url)
}
inline std::string* NodeRegistration::mutable_info_url() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeRegistration.info_url)
  return _internal_mutable_info_url();
}
inline const std::string& NodeRegistration::_internal_info_url() const {
  return info_url_.Get();
}
inline void NodeRegistration::_internal_set_info_url(const std::string& value) {

  info_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeRegistration::set_info_url(std::string&& value) {

  info_url_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeRegistration.info_url)
}
inline void NodeRegistration::set_info_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  info_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeRegistration.info_url)
}
inline void NodeRegistration::set_info_url(const char* value,
    size_t size) {

  info_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeRegistration.info_url)
}
inline std::string* NodeRegistration::_internal_mutable_info_url() {

  return info_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeRegistration::release_info_url() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeRegistration.info_url)
  return info_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRegistration::set_allocated_info_url(std::string* info_url) {
  if (info_url != nullptr) {

  } else {

  }
  info_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeRegistration.info_url)
}

// string country = 5 [json_name = "country", (.validator.field) = {
inline void NodeRegistration::clear_country() {
  country_.ClearToEmpty();
}
inline const std::string& NodeRegistration::country() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeRegistration.country)
  return _internal_country();
}
inline void NodeRegistration::set_country(const std::string& value) {
  _internal_set_country(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeRegistration.country)
}
inline std::string* NodeRegistration::mutable_country() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeRegistration.country)
  return _internal_mutable_country();
}
inline const std::string& NodeRegistration::_internal_country() const {
  return country_.Get();
}
inline void NodeRegistration::_internal_set_country(const std::string& value) {

  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeRegistration::set_country(std::string&& value) {

  country_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeRegistration.country)
}
inline void NodeRegistration::set_country(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeRegistration.country)
}
inline void NodeRegistration::set_country(const char* value,
    size_t size) {

  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeRegistration.country)
}
inline std::string* NodeRegistration::_internal_mutable_country() {

  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeRegistration::release_country() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeRegistration.country)
  return country_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRegistration::set_allocated_country(std::string* country) {
  if (country != nullptr) {

  } else {

  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeRegistration.country)
}

// -------------------------------------------------------------------

// NodeVote

// bytes pub_key = 1 [json_name = "pubKey", (.validator.field) = {
inline void NodeVote::clear_pub_key() {
  pub_key_.ClearToEmpty();
}
inline const std::string& NodeVote::pub_key() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeVote.pub_key)
  return _internal_pub_key();
}
inline void NodeVote::set_pub_key(const std::string& value) {
  _internal_set_pub_key(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeVote.pub_key)
}
inline std::string* NodeVote::mutable_pub_key() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeVote.pub_key)
  return _internal_mutable_pub_key();
}
inline const std::string& NodeVote::_internal_pub_key() const {
  return pub_key_.Get();
}
inline void NodeVote::_internal_set_pub_key(const std::string& value) {

  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeVote::set_pub_key(std::string&& value) {

  pub_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeVote.pub_key)
}
inline void NodeVote::set_pub_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeVote.pub_key)
}
inline void NodeVote::set_pub_key(const void* value,
    size_t size) {

  pub_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeVote.pub_key)
}
inline std::string* NodeVote::_internal_mutable_pub_key() {

  return pub_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeVote::release_pub_key() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeVote.pub_key)
  return pub_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeVote::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {

  } else {

  }
  pub_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pub_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeVote.pub_key)
}

// string reference = 2 [json_name = "reference", (.validator.field) = {
inline void NodeVote::clear_reference() {
  reference_.ClearToEmpty();
}
inline const std::string& NodeVote::reference() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeVote.reference)
  return _internal_reference();
}
inline void NodeVote::set_reference(const std::string& value) {
  _internal_set_reference(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeVote.reference)
}
inline std::string* NodeVote::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeVote.reference)
  return _internal_mutable_reference();
}
inline const std::string& NodeVote::_internal_reference() const {
  return reference_.Get();
}
inline void NodeVote::_internal_set_reference(const std::string& value) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeVote::set_reference(std::string&& value) {

  reference_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeVote.reference)
}
inline void NodeVote::set_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeVote.reference)
}
inline void NodeVote::set_reference(const char* value,
    size_t size) {

  reference_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeVote.reference)
}
inline std::string* NodeVote::_internal_mutable_reference() {

  return reference_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeVote::release_reference() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeVote.reference)
  return reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeVote::set_allocated_reference(std::string* reference) {
  if (reference != nullptr) {

  } else {

  }
  reference_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeVote.reference)
}

// -------------------------------------------------------------------

// NodeSignature

// string id = 1 [json_name = "id"];
inline void NodeSignature::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NodeSignature::id() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeSignature.id)
  return _internal_id();
}
inline void NodeSignature::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeSignature.id)
}
inline std::string* NodeSignature::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeSignature.id)
  return _internal_mutable_id();
}
inline const std::string& NodeSignature::_internal_id() const {
  return id_.Get();
}
inline void NodeSignature::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeSignature::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeSignature.id)
}
inline void NodeSignature::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeSignature.id)
}
inline void NodeSignature::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeSignature.id)
}
inline std::string* NodeSignature::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeSignature::release_id() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeSignature.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeSignature::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeSignature.id)
}

// bytes sig = 2 [json_name = "sig"];
inline void NodeSignature::clear_sig() {
  sig_.ClearToEmpty();
}
inline const std::string& NodeSignature::sig() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeSignature.sig)
  return _internal_sig();
}
inline void NodeSignature::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeSignature.sig)
}
inline std::string* NodeSignature::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.NodeSignature.sig)
  return _internal_mutable_sig();
}
inline const std::string& NodeSignature::_internal_sig() const {
  return sig_.Get();
}
inline void NodeSignature::_internal_set_sig(const std::string& value) {

  sig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeSignature::set_sig(std::string&& value) {

  sig_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.NodeSignature.sig)
}
inline void NodeSignature::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  sig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.NodeSignature.sig)
}
inline void NodeSignature::set_sig(const void* value,
    size_t size) {

  sig_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.NodeSignature.sig)
}
inline std::string* NodeSignature::_internal_mutable_sig() {

  return sig_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeSignature::release_sig() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.NodeSignature.sig)
  return sig_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeSignature::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {

  } else {

  }
  sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.NodeSignature.sig)
}

// .vega.commands.v1.NodeSignatureKind kind = 3 [json_name = "kind"];
inline void NodeSignature::clear_kind() {
  kind_ = 0;
}
inline ::vega::commands::v1::NodeSignatureKind NodeSignature::_internal_kind() const {
  return static_cast< ::vega::commands::v1::NodeSignatureKind >(kind_);
}
inline ::vega::commands::v1::NodeSignatureKind NodeSignature::kind() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.NodeSignature.kind)
  return _internal_kind();
}
inline void NodeSignature::_internal_set_kind(::vega::commands::v1::NodeSignatureKind value) {

  kind_ = value;
}
inline void NodeSignature::set_kind(::vega::commands::v1::NodeSignatureKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.NodeSignature.kind)
}

// -------------------------------------------------------------------

// ChainEvent

// string tx_id = 1 [json_name = "txId"];
inline void ChainEvent::clear_tx_id() {
  tx_id_.ClearToEmpty();
}
inline const std::string& ChainEvent::tx_id() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.tx_id)
  return _internal_tx_id();
}
inline void ChainEvent::set_tx_id(const std::string& value) {
  _internal_set_tx_id(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.ChainEvent.tx_id)
}
inline std::string* ChainEvent::mutable_tx_id() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.tx_id)
  return _internal_mutable_tx_id();
}
inline const std::string& ChainEvent::_internal_tx_id() const {
  return tx_id_.Get();
}
inline void ChainEvent::_internal_set_tx_id(const std::string& value) {

  tx_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ChainEvent::set_tx_id(std::string&& value) {

  tx_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.commands.v1.ChainEvent.tx_id)
}
inline void ChainEvent::set_tx_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  tx_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.commands.v1.ChainEvent.tx_id)
}
inline void ChainEvent::set_tx_id(const char* value,
    size_t size) {

  tx_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.commands.v1.ChainEvent.tx_id)
}
inline std::string* ChainEvent::_internal_mutable_tx_id() {

  return tx_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ChainEvent::release_tx_id() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.tx_id)
  return tx_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChainEvent::set_allocated_tx_id(std::string* tx_id) {
  if (tx_id != nullptr) {

  } else {

  }
  tx_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.commands.v1.ChainEvent.tx_id)
}

// uint64 nonce = 2 [json_name = "nonce"];
inline void ChainEvent::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChainEvent::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ChainEvent::nonce() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.nonce)
  return _internal_nonce();
}
inline void ChainEvent::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  nonce_ = value;
}
inline void ChainEvent::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:vega.commands.v1.ChainEvent.nonce)
}

// .vega.BuiltinAssetEvent builtin = 1001 [json_name = "builtin"];
inline bool ChainEvent::_internal_has_builtin() const {
  return event_case() == kBuiltin;
}
inline bool ChainEvent::has_builtin() const {
  return _internal_has_builtin();
}
inline void ChainEvent::set_has_builtin() {
  _oneof_case_[0] = kBuiltin;
}
inline ::vega::BuiltinAssetEvent* ChainEvent::release_builtin() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.builtin)
  if (_internal_has_builtin()) {
    clear_has_event();
      ::vega::BuiltinAssetEvent* temp = event_.builtin_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.builtin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BuiltinAssetEvent& ChainEvent::_internal_builtin() const {
  return _internal_has_builtin()
      ? *event_.builtin_
      : reinterpret_cast< ::vega::BuiltinAssetEvent&>(::vega::_BuiltinAssetEvent_default_instance_);
}
inline const ::vega::BuiltinAssetEvent& ChainEvent::builtin() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.builtin)
  return _internal_builtin();
}
inline ::vega::BuiltinAssetEvent* ChainEvent::unsafe_arena_release_builtin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.commands.v1.ChainEvent.builtin)
  if (_internal_has_builtin()) {
    clear_has_event();
    ::vega::BuiltinAssetEvent* temp = event_.builtin_;
    event_.builtin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_builtin(::vega::BuiltinAssetEvent* builtin) {
  clear_event();
  if (builtin) {
    set_has_builtin();
    event_.builtin_ = builtin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.commands.v1.ChainEvent.builtin)
}
inline ::vega::BuiltinAssetEvent* ChainEvent::_internal_mutable_builtin() {
  if (!_internal_has_builtin()) {
    clear_event();
    set_has_builtin();
    event_.builtin_ = CreateMaybeMessage< ::vega::BuiltinAssetEvent >(GetArena());
  }
  return event_.builtin_;
}
inline ::vega::BuiltinAssetEvent* ChainEvent::mutable_builtin() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.builtin)
  return _internal_mutable_builtin();
}

// .vega.ERC20Event erc20 = 1002 [json_name = "erc20"];
inline bool ChainEvent::_internal_has_erc20() const {
  return event_case() == kErc20;
}
inline bool ChainEvent::has_erc20() const {
  return _internal_has_erc20();
}
inline void ChainEvent::set_has_erc20() {
  _oneof_case_[0] = kErc20;
}
inline ::vega::ERC20Event* ChainEvent::release_erc20() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.erc20)
  if (_internal_has_erc20()) {
    clear_has_event();
      ::vega::ERC20Event* temp = event_.erc20_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.erc20_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ERC20Event& ChainEvent::_internal_erc20() const {
  return _internal_has_erc20()
      ? *event_.erc20_
      : reinterpret_cast< ::vega::ERC20Event&>(::vega::_ERC20Event_default_instance_);
}
inline const ::vega::ERC20Event& ChainEvent::erc20() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.erc20)
  return _internal_erc20();
}
inline ::vega::ERC20Event* ChainEvent::unsafe_arena_release_erc20() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.commands.v1.ChainEvent.erc20)
  if (_internal_has_erc20()) {
    clear_has_event();
    ::vega::ERC20Event* temp = event_.erc20_;
    event_.erc20_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_erc20(::vega::ERC20Event* erc20) {
  clear_event();
  if (erc20) {
    set_has_erc20();
    event_.erc20_ = erc20;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.commands.v1.ChainEvent.erc20)
}
inline ::vega::ERC20Event* ChainEvent::_internal_mutable_erc20() {
  if (!_internal_has_erc20()) {
    clear_event();
    set_has_erc20();
    event_.erc20_ = CreateMaybeMessage< ::vega::ERC20Event >(GetArena());
  }
  return event_.erc20_;
}
inline ::vega::ERC20Event* ChainEvent::mutable_erc20() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.erc20)
  return _internal_mutable_erc20();
}

// .vega.BTCEvent btc = 1003 [json_name = "btc"];
inline bool ChainEvent::_internal_has_btc() const {
  return event_case() == kBtc;
}
inline bool ChainEvent::has_btc() const {
  return _internal_has_btc();
}
inline void ChainEvent::set_has_btc() {
  _oneof_case_[0] = kBtc;
}
inline ::vega::BTCEvent* ChainEvent::release_btc() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.btc)
  if (_internal_has_btc()) {
    clear_has_event();
      ::vega::BTCEvent* temp = event_.btc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.btc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::BTCEvent& ChainEvent::_internal_btc() const {
  return _internal_has_btc()
      ? *event_.btc_
      : reinterpret_cast< ::vega::BTCEvent&>(::vega::_BTCEvent_default_instance_);
}
inline const ::vega::BTCEvent& ChainEvent::btc() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.btc)
  return _internal_btc();
}
inline ::vega::BTCEvent* ChainEvent::unsafe_arena_release_btc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.commands.v1.ChainEvent.btc)
  if (_internal_has_btc()) {
    clear_has_event();
    ::vega::BTCEvent* temp = event_.btc_;
    event_.btc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_btc(::vega::BTCEvent* btc) {
  clear_event();
  if (btc) {
    set_has_btc();
    event_.btc_ = btc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.commands.v1.ChainEvent.btc)
}
inline ::vega::BTCEvent* ChainEvent::_internal_mutable_btc() {
  if (!_internal_has_btc()) {
    clear_event();
    set_has_btc();
    event_.btc_ = CreateMaybeMessage< ::vega::BTCEvent >(GetArena());
  }
  return event_.btc_;
}
inline ::vega::BTCEvent* ChainEvent::mutable_btc() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.btc)
  return _internal_mutable_btc();
}

// .vega.ValidatorEvent validator = 1004 [json_name = "validator"];
inline bool ChainEvent::_internal_has_validator() const {
  return event_case() == kValidator;
}
inline bool ChainEvent::has_validator() const {
  return _internal_has_validator();
}
inline void ChainEvent::set_has_validator() {
  _oneof_case_[0] = kValidator;
}
inline ::vega::ValidatorEvent* ChainEvent::release_validator() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.validator)
  if (_internal_has_validator()) {
    clear_has_event();
      ::vega::ValidatorEvent* temp = event_.validator_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.validator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ValidatorEvent& ChainEvent::_internal_validator() const {
  return _internal_has_validator()
      ? *event_.validator_
      : reinterpret_cast< ::vega::ValidatorEvent&>(::vega::_ValidatorEvent_default_instance_);
}
inline const ::vega::ValidatorEvent& ChainEvent::validator() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.validator)
  return _internal_validator();
}
inline ::vega::ValidatorEvent* ChainEvent::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.commands.v1.ChainEvent.validator)
  if (_internal_has_validator()) {
    clear_has_event();
    ::vega::ValidatorEvent* temp = event_.validator_;
    event_.validator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_validator(::vega::ValidatorEvent* validator) {
  clear_event();
  if (validator) {
    set_has_validator();
    event_.validator_ = validator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.commands.v1.ChainEvent.validator)
}
inline ::vega::ValidatorEvent* ChainEvent::_internal_mutable_validator() {
  if (!_internal_has_validator()) {
    clear_event();
    set_has_validator();
    event_.validator_ = CreateMaybeMessage< ::vega::ValidatorEvent >(GetArena());
  }
  return event_.validator_;
}
inline ::vega::ValidatorEvent* ChainEvent::mutable_validator() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.validator)
  return _internal_mutable_validator();
}

// .vega.StakingEvent staking_event = 1005 [json_name = "stakingEvent"];
inline bool ChainEvent::_internal_has_staking_event() const {
  return event_case() == kStakingEvent;
}
inline bool ChainEvent::has_staking_event() const {
  return _internal_has_staking_event();
}
inline void ChainEvent::set_has_staking_event() {
  _oneof_case_[0] = kStakingEvent;
}
inline ::vega::StakingEvent* ChainEvent::release_staking_event() {
  // @@protoc_insertion_point(field_release:vega.commands.v1.ChainEvent.staking_event)
  if (_internal_has_staking_event()) {
    clear_has_event();
      ::vega::StakingEvent* temp = event_.staking_event_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.staking_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::StakingEvent& ChainEvent::_internal_staking_event() const {
  return _internal_has_staking_event()
      ? *event_.staking_event_
      : reinterpret_cast< ::vega::StakingEvent&>(::vega::_StakingEvent_default_instance_);
}
inline const ::vega::StakingEvent& ChainEvent::staking_event() const {
  // @@protoc_insertion_point(field_get:vega.commands.v1.ChainEvent.staking_event)
  return _internal_staking_event();
}
inline ::vega::StakingEvent* ChainEvent::unsafe_arena_release_staking_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.commands.v1.ChainEvent.staking_event)
  if (_internal_has_staking_event()) {
    clear_has_event();
    ::vega::StakingEvent* temp = event_.staking_event_;
    event_.staking_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChainEvent::unsafe_arena_set_allocated_staking_event(::vega::StakingEvent* staking_event) {
  clear_event();
  if (staking_event) {
    set_has_staking_event();
    event_.staking_event_ = staking_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.commands.v1.ChainEvent.staking_event)
}
inline ::vega::StakingEvent* ChainEvent::_internal_mutable_staking_event() {
  if (!_internal_has_staking_event()) {
    clear_event();
    set_has_staking_event();
    event_.staking_event_ = CreateMaybeMessage< ::vega::StakingEvent >(GetArena());
  }
  return event_.staking_event_;
}
inline ::vega::StakingEvent* ChainEvent::mutable_staking_event() {
  // @@protoc_insertion_point(field_mutable:vega.commands.v1.ChainEvent.staking_event)
  return _internal_mutable_staking_event();
}

inline bool ChainEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void ChainEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline ChainEvent::EventCase ChainEvent::event_case() const {
  return ChainEvent::EventCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace commands
}  // namespace vega

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vega::commands::v1::NodeSignatureKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::commands::v1::NodeSignatureKind>() {
  return ::vega::commands::v1::NodeSignatureKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_commands_2fv1_2fvalidator_5fcommands_2eproto
