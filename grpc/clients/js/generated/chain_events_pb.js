// source: chain_events.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.vega.AddValidator', null, global);
goog.exportSymbol('proto.vega.BTCDeposit', null, global);
goog.exportSymbol('proto.vega.BTCEvent', null, global);
goog.exportSymbol('proto.vega.BTCEvent.ActionCase', null, global);
goog.exportSymbol('proto.vega.BTCWithdrawal', null, global);
goog.exportSymbol('proto.vega.BitcoinAddress', null, global);
goog.exportSymbol('proto.vega.BuiltinAssetDeposit', null, global);
goog.exportSymbol('proto.vega.BuiltinAssetEvent', null, global);
goog.exportSymbol('proto.vega.BuiltinAssetEvent.ActionCase', null, global);
goog.exportSymbol('proto.vega.BuiltinAssetWithdrawal', null, global);
goog.exportSymbol('proto.vega.ERC20AssetDelist', null, global);
goog.exportSymbol('proto.vega.ERC20AssetList', null, global);
goog.exportSymbol('proto.vega.ERC20Deposit', null, global);
goog.exportSymbol('proto.vega.ERC20Event', null, global);
goog.exportSymbol('proto.vega.ERC20Event.ActionCase', null, global);
goog.exportSymbol('proto.vega.ERC20Withdrawal', null, global);
goog.exportSymbol('proto.vega.EthereumAddress', null, global);
goog.exportSymbol('proto.vega.Identifier', null, global);
goog.exportSymbol('proto.vega.Identifier.IdentifierCase', null, global);
goog.exportSymbol('proto.vega.RemoveValidator', null, global);
goog.exportSymbol('proto.vega.StakeDeposited', null, global);
goog.exportSymbol('proto.vega.StakeRemoved', null, global);
goog.exportSymbol('proto.vega.StakingEvent', null, global);
goog.exportSymbol('proto.vega.StakingEvent.ActionCase', null, global);
goog.exportSymbol('proto.vega.ValidatorEvent', null, global);
goog.exportSymbol('proto.vega.ValidatorEvent.ActionCase', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BuiltinAssetDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.BuiltinAssetDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BuiltinAssetDeposit.displayName = 'proto.vega.BuiltinAssetDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BuiltinAssetWithdrawal = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.BuiltinAssetWithdrawal, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BuiltinAssetWithdrawal.displayName = 'proto.vega.BuiltinAssetWithdrawal';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BuiltinAssetEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, null, proto.vega.BuiltinAssetEvent.oneofGroups_);
};
goog.inherits(proto.vega.BuiltinAssetEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BuiltinAssetEvent.displayName = 'proto.vega.BuiltinAssetEvent';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ERC20AssetList = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.ERC20AssetList, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ERC20AssetList.displayName = 'proto.vega.ERC20AssetList';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ERC20AssetDelist = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.ERC20AssetDelist, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ERC20AssetDelist.displayName = 'proto.vega.ERC20AssetDelist';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ERC20Deposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.ERC20Deposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ERC20Deposit.displayName = 'proto.vega.ERC20Deposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ERC20Withdrawal = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.ERC20Withdrawal, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ERC20Withdrawal.displayName = 'proto.vega.ERC20Withdrawal';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ERC20Event = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, null, proto.vega.ERC20Event.oneofGroups_);
};
goog.inherits(proto.vega.ERC20Event, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ERC20Event.displayName = 'proto.vega.ERC20Event';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BTCDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.BTCDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BTCDeposit.displayName = 'proto.vega.BTCDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BTCWithdrawal = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.BTCWithdrawal, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BTCWithdrawal.displayName = 'proto.vega.BTCWithdrawal';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BTCEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, null, proto.vega.BTCEvent.oneofGroups_);
};
goog.inherits(proto.vega.BTCEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BTCEvent.displayName = 'proto.vega.BTCEvent';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.EthereumAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.EthereumAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.EthereumAddress.displayName = 'proto.vega.EthereumAddress';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.BitcoinAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.BitcoinAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.BitcoinAddress.displayName = 'proto.vega.BitcoinAddress';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.Identifier = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.vega.Identifier.oneofGroups_);
};
goog.inherits(proto.vega.Identifier, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.Identifier.displayName = 'proto.vega.Identifier';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.AddValidator = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.AddValidator, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.AddValidator.displayName = 'proto.vega.AddValidator';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.RemoveValidator = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.RemoveValidator, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.RemoveValidator.displayName = 'proto.vega.RemoveValidator';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.ValidatorEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, null, proto.vega.ValidatorEvent.oneofGroups_);
};
goog.inherits(proto.vega.ValidatorEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.ValidatorEvent.displayName = 'proto.vega.ValidatorEvent';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.StakingEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, null, proto.vega.StakingEvent.oneofGroups_);
};
goog.inherits(proto.vega.StakingEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.StakingEvent.displayName = 'proto.vega.StakingEvent';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.StakeDeposited = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.StakeDeposited, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.StakeDeposited.displayName = 'proto.vega.StakeDeposited';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.vega.StakeRemoved = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.vega.StakeRemoved, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.vega.StakeRemoved.displayName = 'proto.vega.StakeRemoved';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BuiltinAssetDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BuiltinAssetDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BuiltinAssetDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    partyId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BuiltinAssetDeposit}
 */
proto.vega.BuiltinAssetDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BuiltinAssetDeposit;
  return proto.vega.BuiltinAssetDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BuiltinAssetDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BuiltinAssetDeposit}
 */
proto.vega.BuiltinAssetDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPartyId(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BuiltinAssetDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BuiltinAssetDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BuiltinAssetDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPartyId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.BuiltinAssetDeposit.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BuiltinAssetDeposit} returns this
 */
proto.vega.BuiltinAssetDeposit.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string party_id = 2;
 * @return {string}
 */
proto.vega.BuiltinAssetDeposit.prototype.getPartyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BuiltinAssetDeposit} returns this
 */
proto.vega.BuiltinAssetDeposit.prototype.setPartyId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint64 amount = 3;
 * @return {number}
 */
proto.vega.BuiltinAssetDeposit.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.BuiltinAssetDeposit} returns this
 */
proto.vega.BuiltinAssetDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BuiltinAssetWithdrawal.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BuiltinAssetWithdrawal.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BuiltinAssetWithdrawal} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetWithdrawal.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    partyId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BuiltinAssetWithdrawal}
 */
proto.vega.BuiltinAssetWithdrawal.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BuiltinAssetWithdrawal;
  return proto.vega.BuiltinAssetWithdrawal.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BuiltinAssetWithdrawal} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BuiltinAssetWithdrawal}
 */
proto.vega.BuiltinAssetWithdrawal.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPartyId(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BuiltinAssetWithdrawal.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BuiltinAssetWithdrawal.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BuiltinAssetWithdrawal} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetWithdrawal.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPartyId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.BuiltinAssetWithdrawal.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BuiltinAssetWithdrawal} returns this
 */
proto.vega.BuiltinAssetWithdrawal.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string party_id = 2;
 * @return {string}
 */
proto.vega.BuiltinAssetWithdrawal.prototype.getPartyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BuiltinAssetWithdrawal} returns this
 */
proto.vega.BuiltinAssetWithdrawal.prototype.setPartyId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional uint64 amount = 3;
 * @return {number}
 */
proto.vega.BuiltinAssetWithdrawal.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.BuiltinAssetWithdrawal} returns this
 */
proto.vega.BuiltinAssetWithdrawal.prototype.setAmount = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.BuiltinAssetEvent.oneofGroups_ = [[1001,1002]];

/**
 * @enum {number}
 */
proto.vega.BuiltinAssetEvent.ActionCase = {
  ACTION_NOT_SET: 0,
  DEPOSIT: 1001,
  WITHDRAWAL: 1002
};

/**
 * @return {proto.vega.BuiltinAssetEvent.ActionCase}
 */
proto.vega.BuiltinAssetEvent.prototype.getActionCase = function() {
  return /** @type {proto.vega.BuiltinAssetEvent.ActionCase} */(jspb.Message.computeOneofCase(this, proto.vega.BuiltinAssetEvent.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BuiltinAssetEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BuiltinAssetEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BuiltinAssetEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    deposit: (f = msg.getDeposit()) && proto.vega.BuiltinAssetDeposit.toObject(includeInstance, f),
    withdrawal: (f = msg.getWithdrawal()) && proto.vega.BuiltinAssetWithdrawal.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BuiltinAssetEvent}
 */
proto.vega.BuiltinAssetEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BuiltinAssetEvent;
  return proto.vega.BuiltinAssetEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BuiltinAssetEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BuiltinAssetEvent}
 */
proto.vega.BuiltinAssetEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1001:
      var value = new proto.vega.BuiltinAssetDeposit;
      reader.readMessage(value,proto.vega.BuiltinAssetDeposit.deserializeBinaryFromReader);
      msg.setDeposit(value);
      break;
    case 1002:
      var value = new proto.vega.BuiltinAssetWithdrawal;
      reader.readMessage(value,proto.vega.BuiltinAssetWithdrawal.deserializeBinaryFromReader);
      msg.setWithdrawal(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BuiltinAssetEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BuiltinAssetEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BuiltinAssetEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BuiltinAssetEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDeposit();
  if (f != null) {
    writer.writeMessage(
      1001,
      f,
      proto.vega.BuiltinAssetDeposit.serializeBinaryToWriter
    );
  }
  f = message.getWithdrawal();
  if (f != null) {
    writer.writeMessage(
      1002,
      f,
      proto.vega.BuiltinAssetWithdrawal.serializeBinaryToWriter
    );
  }
};


/**
 * optional BuiltinAssetDeposit deposit = 1001;
 * @return {?proto.vega.BuiltinAssetDeposit}
 */
proto.vega.BuiltinAssetEvent.prototype.getDeposit = function() {
  return /** @type{?proto.vega.BuiltinAssetDeposit} */ (
    jspb.Message.getWrapperField(this, proto.vega.BuiltinAssetDeposit, 1001));
};


/**
 * @param {?proto.vega.BuiltinAssetDeposit|undefined} value
 * @return {!proto.vega.BuiltinAssetEvent} returns this
*/
proto.vega.BuiltinAssetEvent.prototype.setDeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1001, proto.vega.BuiltinAssetEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.BuiltinAssetEvent} returns this
 */
proto.vega.BuiltinAssetEvent.prototype.clearDeposit = function() {
  return this.setDeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.BuiltinAssetEvent.prototype.hasDeposit = function() {
  return jspb.Message.getField(this, 1001) != null;
};


/**
 * optional BuiltinAssetWithdrawal withdrawal = 1002;
 * @return {?proto.vega.BuiltinAssetWithdrawal}
 */
proto.vega.BuiltinAssetEvent.prototype.getWithdrawal = function() {
  return /** @type{?proto.vega.BuiltinAssetWithdrawal} */ (
    jspb.Message.getWrapperField(this, proto.vega.BuiltinAssetWithdrawal, 1002));
};


/**
 * @param {?proto.vega.BuiltinAssetWithdrawal|undefined} value
 * @return {!proto.vega.BuiltinAssetEvent} returns this
*/
proto.vega.BuiltinAssetEvent.prototype.setWithdrawal = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1002, proto.vega.BuiltinAssetEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.BuiltinAssetEvent} returns this
 */
proto.vega.BuiltinAssetEvent.prototype.clearWithdrawal = function() {
  return this.setWithdrawal(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.BuiltinAssetEvent.prototype.hasWithdrawal = function() {
  return jspb.Message.getField(this, 1002) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ERC20AssetList.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ERC20AssetList.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ERC20AssetList} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20AssetList.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ERC20AssetList}
 */
proto.vega.ERC20AssetList.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ERC20AssetList;
  return proto.vega.ERC20AssetList.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ERC20AssetList} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ERC20AssetList}
 */
proto.vega.ERC20AssetList.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ERC20AssetList.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ERC20AssetList.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ERC20AssetList} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20AssetList.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.ERC20AssetList.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20AssetList} returns this
 */
proto.vega.ERC20AssetList.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ERC20AssetDelist.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ERC20AssetDelist.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ERC20AssetDelist} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20AssetDelist.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ERC20AssetDelist}
 */
proto.vega.ERC20AssetDelist.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ERC20AssetDelist;
  return proto.vega.ERC20AssetDelist.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ERC20AssetDelist} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ERC20AssetDelist}
 */
proto.vega.ERC20AssetDelist.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ERC20AssetDelist.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ERC20AssetDelist.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ERC20AssetDelist} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20AssetDelist.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.ERC20AssetDelist.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20AssetDelist} returns this
 */
proto.vega.ERC20AssetDelist.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ERC20Deposit.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ERC20Deposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ERC20Deposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Deposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    sourceEthereumAddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    targetPartyId: jspb.Message.getFieldWithDefault(msg, 3, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ERC20Deposit}
 */
proto.vega.ERC20Deposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ERC20Deposit;
  return proto.vega.ERC20Deposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ERC20Deposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ERC20Deposit}
 */
proto.vega.ERC20Deposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourceEthereumAddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTargetPartyId(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ERC20Deposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ERC20Deposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ERC20Deposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Deposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSourceEthereumAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTargetPartyId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.ERC20Deposit.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Deposit} returns this
 */
proto.vega.ERC20Deposit.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string source_ethereum_address = 2;
 * @return {string}
 */
proto.vega.ERC20Deposit.prototype.getSourceEthereumAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Deposit} returns this
 */
proto.vega.ERC20Deposit.prototype.setSourceEthereumAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string target_party_id = 3;
 * @return {string}
 */
proto.vega.ERC20Deposit.prototype.getTargetPartyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Deposit} returns this
 */
proto.vega.ERC20Deposit.prototype.setTargetPartyId = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string amount = 4;
 * @return {string}
 */
proto.vega.ERC20Deposit.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Deposit} returns this
 */
proto.vega.ERC20Deposit.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ERC20Withdrawal.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ERC20Withdrawal.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ERC20Withdrawal} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Withdrawal.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    targetEthereumAddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    referenceNonce: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ERC20Withdrawal}
 */
proto.vega.ERC20Withdrawal.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ERC20Withdrawal;
  return proto.vega.ERC20Withdrawal.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ERC20Withdrawal} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ERC20Withdrawal}
 */
proto.vega.ERC20Withdrawal.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTargetEthereumAddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setReferenceNonce(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ERC20Withdrawal.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ERC20Withdrawal.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ERC20Withdrawal} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Withdrawal.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTargetEthereumAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getReferenceNonce();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.ERC20Withdrawal.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Withdrawal} returns this
 */
proto.vega.ERC20Withdrawal.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string target_ethereum_address = 2;
 * @return {string}
 */
proto.vega.ERC20Withdrawal.prototype.getTargetEthereumAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Withdrawal} returns this
 */
proto.vega.ERC20Withdrawal.prototype.setTargetEthereumAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string reference_nonce = 3;
 * @return {string}
 */
proto.vega.ERC20Withdrawal.prototype.getReferenceNonce = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ERC20Withdrawal} returns this
 */
proto.vega.ERC20Withdrawal.prototype.setReferenceNonce = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.ERC20Event.oneofGroups_ = [[1001,1002,1003,1004]];

/**
 * @enum {number}
 */
proto.vega.ERC20Event.ActionCase = {
  ACTION_NOT_SET: 0,
  ASSET_LIST: 1001,
  ASSET_DELIST: 1002,
  DEPOSIT: 1003,
  WITHDRAWAL: 1004
};

/**
 * @return {proto.vega.ERC20Event.ActionCase}
 */
proto.vega.ERC20Event.prototype.getActionCase = function() {
  return /** @type {proto.vega.ERC20Event.ActionCase} */(jspb.Message.computeOneofCase(this, proto.vega.ERC20Event.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ERC20Event.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ERC20Event.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ERC20Event} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Event.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    block: jspb.Message.getFieldWithDefault(msg, 2, 0),
    assetList: (f = msg.getAssetList()) && proto.vega.ERC20AssetList.toObject(includeInstance, f),
    assetDelist: (f = msg.getAssetDelist()) && proto.vega.ERC20AssetDelist.toObject(includeInstance, f),
    deposit: (f = msg.getDeposit()) && proto.vega.ERC20Deposit.toObject(includeInstance, f),
    withdrawal: (f = msg.getWithdrawal()) && proto.vega.ERC20Withdrawal.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ERC20Event}
 */
proto.vega.ERC20Event.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ERC20Event;
  return proto.vega.ERC20Event.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ERC20Event} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ERC20Event}
 */
proto.vega.ERC20Event.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlock(value);
      break;
    case 1001:
      var value = new proto.vega.ERC20AssetList;
      reader.readMessage(value,proto.vega.ERC20AssetList.deserializeBinaryFromReader);
      msg.setAssetList(value);
      break;
    case 1002:
      var value = new proto.vega.ERC20AssetDelist;
      reader.readMessage(value,proto.vega.ERC20AssetDelist.deserializeBinaryFromReader);
      msg.setAssetDelist(value);
      break;
    case 1003:
      var value = new proto.vega.ERC20Deposit;
      reader.readMessage(value,proto.vega.ERC20Deposit.deserializeBinaryFromReader);
      msg.setDeposit(value);
      break;
    case 1004:
      var value = new proto.vega.ERC20Withdrawal;
      reader.readMessage(value,proto.vega.ERC20Withdrawal.deserializeBinaryFromReader);
      msg.setWithdrawal(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ERC20Event.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ERC20Event.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ERC20Event} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ERC20Event.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getBlock();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getAssetList();
  if (f != null) {
    writer.writeMessage(
      1001,
      f,
      proto.vega.ERC20AssetList.serializeBinaryToWriter
    );
  }
  f = message.getAssetDelist();
  if (f != null) {
    writer.writeMessage(
      1002,
      f,
      proto.vega.ERC20AssetDelist.serializeBinaryToWriter
    );
  }
  f = message.getDeposit();
  if (f != null) {
    writer.writeMessage(
      1003,
      f,
      proto.vega.ERC20Deposit.serializeBinaryToWriter
    );
  }
  f = message.getWithdrawal();
  if (f != null) {
    writer.writeMessage(
      1004,
      f,
      proto.vega.ERC20Withdrawal.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 index = 1;
 * @return {number}
 */
proto.vega.ERC20Event.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 block = 2;
 * @return {number}
 */
proto.vega.ERC20Event.prototype.getBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.setBlock = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional ERC20AssetList asset_list = 1001;
 * @return {?proto.vega.ERC20AssetList}
 */
proto.vega.ERC20Event.prototype.getAssetList = function() {
  return /** @type{?proto.vega.ERC20AssetList} */ (
    jspb.Message.getWrapperField(this, proto.vega.ERC20AssetList, 1001));
};


/**
 * @param {?proto.vega.ERC20AssetList|undefined} value
 * @return {!proto.vega.ERC20Event} returns this
*/
proto.vega.ERC20Event.prototype.setAssetList = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1001, proto.vega.ERC20Event.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.clearAssetList = function() {
  return this.setAssetList(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ERC20Event.prototype.hasAssetList = function() {
  return jspb.Message.getField(this, 1001) != null;
};


/**
 * optional ERC20AssetDelist asset_delist = 1002;
 * @return {?proto.vega.ERC20AssetDelist}
 */
proto.vega.ERC20Event.prototype.getAssetDelist = function() {
  return /** @type{?proto.vega.ERC20AssetDelist} */ (
    jspb.Message.getWrapperField(this, proto.vega.ERC20AssetDelist, 1002));
};


/**
 * @param {?proto.vega.ERC20AssetDelist|undefined} value
 * @return {!proto.vega.ERC20Event} returns this
*/
proto.vega.ERC20Event.prototype.setAssetDelist = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1002, proto.vega.ERC20Event.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.clearAssetDelist = function() {
  return this.setAssetDelist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ERC20Event.prototype.hasAssetDelist = function() {
  return jspb.Message.getField(this, 1002) != null;
};


/**
 * optional ERC20Deposit deposit = 1003;
 * @return {?proto.vega.ERC20Deposit}
 */
proto.vega.ERC20Event.prototype.getDeposit = function() {
  return /** @type{?proto.vega.ERC20Deposit} */ (
    jspb.Message.getWrapperField(this, proto.vega.ERC20Deposit, 1003));
};


/**
 * @param {?proto.vega.ERC20Deposit|undefined} value
 * @return {!proto.vega.ERC20Event} returns this
*/
proto.vega.ERC20Event.prototype.setDeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1003, proto.vega.ERC20Event.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.clearDeposit = function() {
  return this.setDeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ERC20Event.prototype.hasDeposit = function() {
  return jspb.Message.getField(this, 1003) != null;
};


/**
 * optional ERC20Withdrawal withdrawal = 1004;
 * @return {?proto.vega.ERC20Withdrawal}
 */
proto.vega.ERC20Event.prototype.getWithdrawal = function() {
  return /** @type{?proto.vega.ERC20Withdrawal} */ (
    jspb.Message.getWrapperField(this, proto.vega.ERC20Withdrawal, 1004));
};


/**
 * @param {?proto.vega.ERC20Withdrawal|undefined} value
 * @return {!proto.vega.ERC20Event} returns this
*/
proto.vega.ERC20Event.prototype.setWithdrawal = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1004, proto.vega.ERC20Event.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ERC20Event} returns this
 */
proto.vega.ERC20Event.prototype.clearWithdrawal = function() {
  return this.setWithdrawal(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ERC20Event.prototype.hasWithdrawal = function() {
  return jspb.Message.getField(this, 1004) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BTCDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BTCDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BTCDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    sourceBtcAddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    targetPartyId: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BTCDeposit}
 */
proto.vega.BTCDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BTCDeposit;
  return proto.vega.BTCDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BTCDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BTCDeposit}
 */
proto.vega.BTCDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourceBtcAddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTargetPartyId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BTCDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BTCDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BTCDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSourceBtcAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTargetPartyId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.BTCDeposit.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCDeposit} returns this
 */
proto.vega.BTCDeposit.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string source_btc_address = 2;
 * @return {string}
 */
proto.vega.BTCDeposit.prototype.getSourceBtcAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCDeposit} returns this
 */
proto.vega.BTCDeposit.prototype.setSourceBtcAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string target_party_id = 3;
 * @return {string}
 */
proto.vega.BTCDeposit.prototype.getTargetPartyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCDeposit} returns this
 */
proto.vega.BTCDeposit.prototype.setTargetPartyId = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BTCWithdrawal.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BTCWithdrawal.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BTCWithdrawal} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCWithdrawal.toObject = function(includeInstance, msg) {
  var f, obj = {
    vegaAssetId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    sourcePartyId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    targetBtcAddress: jspb.Message.getFieldWithDefault(msg, 3, ""),
    referenceNonce: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BTCWithdrawal}
 */
proto.vega.BTCWithdrawal.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BTCWithdrawal;
  return proto.vega.BTCWithdrawal.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BTCWithdrawal} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BTCWithdrawal}
 */
proto.vega.BTCWithdrawal.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaAssetId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourcePartyId(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTargetBtcAddress(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setReferenceNonce(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BTCWithdrawal.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BTCWithdrawal.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BTCWithdrawal} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCWithdrawal.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVegaAssetId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSourcePartyId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTargetBtcAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getReferenceNonce();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string vega_asset_id = 1;
 * @return {string}
 */
proto.vega.BTCWithdrawal.prototype.getVegaAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCWithdrawal} returns this
 */
proto.vega.BTCWithdrawal.prototype.setVegaAssetId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string source_party_id = 2;
 * @return {string}
 */
proto.vega.BTCWithdrawal.prototype.getSourcePartyId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCWithdrawal} returns this
 */
proto.vega.BTCWithdrawal.prototype.setSourcePartyId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string target_btc_address = 3;
 * @return {string}
 */
proto.vega.BTCWithdrawal.prototype.getTargetBtcAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCWithdrawal} returns this
 */
proto.vega.BTCWithdrawal.prototype.setTargetBtcAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string reference_nonce = 4;
 * @return {string}
 */
proto.vega.BTCWithdrawal.prototype.getReferenceNonce = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BTCWithdrawal} returns this
 */
proto.vega.BTCWithdrawal.prototype.setReferenceNonce = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.BTCEvent.oneofGroups_ = [[1001,1002]];

/**
 * @enum {number}
 */
proto.vega.BTCEvent.ActionCase = {
  ACTION_NOT_SET: 0,
  DEPOSIT: 1001,
  WITHDRAWAL: 1002
};

/**
 * @return {proto.vega.BTCEvent.ActionCase}
 */
proto.vega.BTCEvent.prototype.getActionCase = function() {
  return /** @type {proto.vega.BTCEvent.ActionCase} */(jspb.Message.computeOneofCase(this, proto.vega.BTCEvent.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BTCEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BTCEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BTCEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    block: jspb.Message.getFieldWithDefault(msg, 2, 0),
    deposit: (f = msg.getDeposit()) && proto.vega.BTCDeposit.toObject(includeInstance, f),
    withdrawal: (f = msg.getWithdrawal()) && proto.vega.BTCWithdrawal.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BTCEvent}
 */
proto.vega.BTCEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BTCEvent;
  return proto.vega.BTCEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BTCEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BTCEvent}
 */
proto.vega.BTCEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlock(value);
      break;
    case 1001:
      var value = new proto.vega.BTCDeposit;
      reader.readMessage(value,proto.vega.BTCDeposit.deserializeBinaryFromReader);
      msg.setDeposit(value);
      break;
    case 1002:
      var value = new proto.vega.BTCWithdrawal;
      reader.readMessage(value,proto.vega.BTCWithdrawal.deserializeBinaryFromReader);
      msg.setWithdrawal(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BTCEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BTCEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BTCEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BTCEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getBlock();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getDeposit();
  if (f != null) {
    writer.writeMessage(
      1001,
      f,
      proto.vega.BTCDeposit.serializeBinaryToWriter
    );
  }
  f = message.getWithdrawal();
  if (f != null) {
    writer.writeMessage(
      1002,
      f,
      proto.vega.BTCWithdrawal.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 index = 1;
 * @return {number}
 */
proto.vega.BTCEvent.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.BTCEvent} returns this
 */
proto.vega.BTCEvent.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 block = 2;
 * @return {number}
 */
proto.vega.BTCEvent.prototype.getBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.BTCEvent} returns this
 */
proto.vega.BTCEvent.prototype.setBlock = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional BTCDeposit deposit = 1001;
 * @return {?proto.vega.BTCDeposit}
 */
proto.vega.BTCEvent.prototype.getDeposit = function() {
  return /** @type{?proto.vega.BTCDeposit} */ (
    jspb.Message.getWrapperField(this, proto.vega.BTCDeposit, 1001));
};


/**
 * @param {?proto.vega.BTCDeposit|undefined} value
 * @return {!proto.vega.BTCEvent} returns this
*/
proto.vega.BTCEvent.prototype.setDeposit = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1001, proto.vega.BTCEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.BTCEvent} returns this
 */
proto.vega.BTCEvent.prototype.clearDeposit = function() {
  return this.setDeposit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.BTCEvent.prototype.hasDeposit = function() {
  return jspb.Message.getField(this, 1001) != null;
};


/**
 * optional BTCWithdrawal withdrawal = 1002;
 * @return {?proto.vega.BTCWithdrawal}
 */
proto.vega.BTCEvent.prototype.getWithdrawal = function() {
  return /** @type{?proto.vega.BTCWithdrawal} */ (
    jspb.Message.getWrapperField(this, proto.vega.BTCWithdrawal, 1002));
};


/**
 * @param {?proto.vega.BTCWithdrawal|undefined} value
 * @return {!proto.vega.BTCEvent} returns this
*/
proto.vega.BTCEvent.prototype.setWithdrawal = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1002, proto.vega.BTCEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.BTCEvent} returns this
 */
proto.vega.BTCEvent.prototype.clearWithdrawal = function() {
  return this.setWithdrawal(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.BTCEvent.prototype.hasWithdrawal = function() {
  return jspb.Message.getField(this, 1002) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.EthereumAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.EthereumAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.EthereumAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.EthereumAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.EthereumAddress}
 */
proto.vega.EthereumAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.EthereumAddress;
  return proto.vega.EthereumAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.EthereumAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.EthereumAddress}
 */
proto.vega.EthereumAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.EthereumAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.EthereumAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.EthereumAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.EthereumAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.vega.EthereumAddress.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.EthereumAddress} returns this
 */
proto.vega.EthereumAddress.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.BitcoinAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.BitcoinAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.BitcoinAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BitcoinAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.BitcoinAddress}
 */
proto.vega.BitcoinAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.BitcoinAddress;
  return proto.vega.BitcoinAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.BitcoinAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.BitcoinAddress}
 */
proto.vega.BitcoinAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.BitcoinAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.BitcoinAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.BitcoinAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.BitcoinAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.vega.BitcoinAddress.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.BitcoinAddress} returns this
 */
proto.vega.BitcoinAddress.prototype.setAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.Identifier.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.vega.Identifier.IdentifierCase = {
  IDENTIFIER_NOT_SET: 0,
  ETHEREUM_ADDRESS: 1,
  BITCOIN_ADDRESS: 2
};

/**
 * @return {proto.vega.Identifier.IdentifierCase}
 */
proto.vega.Identifier.prototype.getIdentifierCase = function() {
  return /** @type {proto.vega.Identifier.IdentifierCase} */(jspb.Message.computeOneofCase(this, proto.vega.Identifier.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.Identifier.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.Identifier.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.Identifier} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.Identifier.toObject = function(includeInstance, msg) {
  var f, obj = {
    ethereumAddress: (f = msg.getEthereumAddress()) && proto.vega.EthereumAddress.toObject(includeInstance, f),
    bitcoinAddress: (f = msg.getBitcoinAddress()) && proto.vega.BitcoinAddress.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.Identifier}
 */
proto.vega.Identifier.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.Identifier;
  return proto.vega.Identifier.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.Identifier} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.Identifier}
 */
proto.vega.Identifier.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.vega.EthereumAddress;
      reader.readMessage(value,proto.vega.EthereumAddress.deserializeBinaryFromReader);
      msg.setEthereumAddress(value);
      break;
    case 2:
      var value = new proto.vega.BitcoinAddress;
      reader.readMessage(value,proto.vega.BitcoinAddress.deserializeBinaryFromReader);
      msg.setBitcoinAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.Identifier.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.Identifier.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.Identifier} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.Identifier.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEthereumAddress();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.vega.EthereumAddress.serializeBinaryToWriter
    );
  }
  f = message.getBitcoinAddress();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.vega.BitcoinAddress.serializeBinaryToWriter
    );
  }
};


/**
 * optional EthereumAddress ethereum_address = 1;
 * @return {?proto.vega.EthereumAddress}
 */
proto.vega.Identifier.prototype.getEthereumAddress = function() {
  return /** @type{?proto.vega.EthereumAddress} */ (
    jspb.Message.getWrapperField(this, proto.vega.EthereumAddress, 1));
};


/**
 * @param {?proto.vega.EthereumAddress|undefined} value
 * @return {!proto.vega.Identifier} returns this
*/
proto.vega.Identifier.prototype.setEthereumAddress = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.vega.Identifier.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.Identifier} returns this
 */
proto.vega.Identifier.prototype.clearEthereumAddress = function() {
  return this.setEthereumAddress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.Identifier.prototype.hasEthereumAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional BitcoinAddress bitcoin_address = 2;
 * @return {?proto.vega.BitcoinAddress}
 */
proto.vega.Identifier.prototype.getBitcoinAddress = function() {
  return /** @type{?proto.vega.BitcoinAddress} */ (
    jspb.Message.getWrapperField(this, proto.vega.BitcoinAddress, 2));
};


/**
 * @param {?proto.vega.BitcoinAddress|undefined} value
 * @return {!proto.vega.Identifier} returns this
*/
proto.vega.Identifier.prototype.setBitcoinAddress = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.vega.Identifier.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.Identifier} returns this
 */
proto.vega.Identifier.prototype.clearBitcoinAddress = function() {
  return this.setBitcoinAddress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.Identifier.prototype.hasBitcoinAddress = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.AddValidator.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.AddValidator.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.AddValidator} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.AddValidator.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = msg.getId()) && proto.vega.Identifier.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.AddValidator}
 */
proto.vega.AddValidator.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.AddValidator;
  return proto.vega.AddValidator.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.AddValidator} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.AddValidator}
 */
proto.vega.AddValidator.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.vega.Identifier;
      reader.readMessage(value,proto.vega.Identifier.deserializeBinaryFromReader);
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.AddValidator.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.AddValidator.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.AddValidator} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.AddValidator.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.vega.Identifier.serializeBinaryToWriter
    );
  }
};


/**
 * optional Identifier id = 1;
 * @return {?proto.vega.Identifier}
 */
proto.vega.AddValidator.prototype.getId = function() {
  return /** @type{?proto.vega.Identifier} */ (
    jspb.Message.getWrapperField(this, proto.vega.Identifier, 1));
};


/**
 * @param {?proto.vega.Identifier|undefined} value
 * @return {!proto.vega.AddValidator} returns this
*/
proto.vega.AddValidator.prototype.setId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.AddValidator} returns this
 */
proto.vega.AddValidator.prototype.clearId = function() {
  return this.setId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.AddValidator.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.RemoveValidator.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.RemoveValidator.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.RemoveValidator} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.RemoveValidator.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = msg.getId()) && proto.vega.Identifier.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.RemoveValidator}
 */
proto.vega.RemoveValidator.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.RemoveValidator;
  return proto.vega.RemoveValidator.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.RemoveValidator} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.RemoveValidator}
 */
proto.vega.RemoveValidator.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.vega.Identifier;
      reader.readMessage(value,proto.vega.Identifier.deserializeBinaryFromReader);
      msg.setId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.RemoveValidator.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.RemoveValidator.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.RemoveValidator} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.RemoveValidator.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.vega.Identifier.serializeBinaryToWriter
    );
  }
};


/**
 * optional Identifier id = 1;
 * @return {?proto.vega.Identifier}
 */
proto.vega.RemoveValidator.prototype.getId = function() {
  return /** @type{?proto.vega.Identifier} */ (
    jspb.Message.getWrapperField(this, proto.vega.Identifier, 1));
};


/**
 * @param {?proto.vega.Identifier|undefined} value
 * @return {!proto.vega.RemoveValidator} returns this
*/
proto.vega.RemoveValidator.prototype.setId = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.RemoveValidator} returns this
 */
proto.vega.RemoveValidator.prototype.clearId = function() {
  return this.setId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.RemoveValidator.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.ValidatorEvent.oneofGroups_ = [[1001,1002]];

/**
 * @enum {number}
 */
proto.vega.ValidatorEvent.ActionCase = {
  ACTION_NOT_SET: 0,
  ADD: 1001,
  RM: 1002
};

/**
 * @return {proto.vega.ValidatorEvent.ActionCase}
 */
proto.vega.ValidatorEvent.prototype.getActionCase = function() {
  return /** @type {proto.vega.ValidatorEvent.ActionCase} */(jspb.Message.computeOneofCase(this, proto.vega.ValidatorEvent.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.ValidatorEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.ValidatorEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.ValidatorEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ValidatorEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    sourceId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    add: (f = msg.getAdd()) && proto.vega.AddValidator.toObject(includeInstance, f),
    rm: (f = msg.getRm()) && proto.vega.RemoveValidator.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.ValidatorEvent}
 */
proto.vega.ValidatorEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.ValidatorEvent;
  return proto.vega.ValidatorEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.ValidatorEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.ValidatorEvent}
 */
proto.vega.ValidatorEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourceId(value);
      break;
    case 1001:
      var value = new proto.vega.AddValidator;
      reader.readMessage(value,proto.vega.AddValidator.deserializeBinaryFromReader);
      msg.setAdd(value);
      break;
    case 1002:
      var value = new proto.vega.RemoveValidator;
      reader.readMessage(value,proto.vega.RemoveValidator.deserializeBinaryFromReader);
      msg.setRm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.ValidatorEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.ValidatorEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.ValidatorEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.ValidatorEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSourceId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAdd();
  if (f != null) {
    writer.writeMessage(
      1001,
      f,
      proto.vega.AddValidator.serializeBinaryToWriter
    );
  }
  f = message.getRm();
  if (f != null) {
    writer.writeMessage(
      1002,
      f,
      proto.vega.RemoveValidator.serializeBinaryToWriter
    );
  }
};


/**
 * optional string source_id = 1;
 * @return {string}
 */
proto.vega.ValidatorEvent.prototype.getSourceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.ValidatorEvent} returns this
 */
proto.vega.ValidatorEvent.prototype.setSourceId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional AddValidator add = 1001;
 * @return {?proto.vega.AddValidator}
 */
proto.vega.ValidatorEvent.prototype.getAdd = function() {
  return /** @type{?proto.vega.AddValidator} */ (
    jspb.Message.getWrapperField(this, proto.vega.AddValidator, 1001));
};


/**
 * @param {?proto.vega.AddValidator|undefined} value
 * @return {!proto.vega.ValidatorEvent} returns this
*/
proto.vega.ValidatorEvent.prototype.setAdd = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1001, proto.vega.ValidatorEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ValidatorEvent} returns this
 */
proto.vega.ValidatorEvent.prototype.clearAdd = function() {
  return this.setAdd(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ValidatorEvent.prototype.hasAdd = function() {
  return jspb.Message.getField(this, 1001) != null;
};


/**
 * optional RemoveValidator rm = 1002;
 * @return {?proto.vega.RemoveValidator}
 */
proto.vega.ValidatorEvent.prototype.getRm = function() {
  return /** @type{?proto.vega.RemoveValidator} */ (
    jspb.Message.getWrapperField(this, proto.vega.RemoveValidator, 1002));
};


/**
 * @param {?proto.vega.RemoveValidator|undefined} value
 * @return {!proto.vega.ValidatorEvent} returns this
*/
proto.vega.ValidatorEvent.prototype.setRm = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1002, proto.vega.ValidatorEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.ValidatorEvent} returns this
 */
proto.vega.ValidatorEvent.prototype.clearRm = function() {
  return this.setRm(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.ValidatorEvent.prototype.hasRm = function() {
  return jspb.Message.getField(this, 1002) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.vega.StakingEvent.oneofGroups_ = [[1001,1002]];

/**
 * @enum {number}
 */
proto.vega.StakingEvent.ActionCase = {
  ACTION_NOT_SET: 0,
  STAKE_DEPOSITED: 1001,
  STAKE_REMOVED: 1002
};

/**
 * @return {proto.vega.StakingEvent.ActionCase}
 */
proto.vega.StakingEvent.prototype.getActionCase = function() {
  return /** @type {proto.vega.StakingEvent.ActionCase} */(jspb.Message.computeOneofCase(this, proto.vega.StakingEvent.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.StakingEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.StakingEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.StakingEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakingEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    block: jspb.Message.getFieldWithDefault(msg, 2, 0),
    stakeDeposited: (f = msg.getStakeDeposited()) && proto.vega.StakeDeposited.toObject(includeInstance, f),
    stakeRemoved: (f = msg.getStakeRemoved()) && proto.vega.StakeRemoved.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.StakingEvent}
 */
proto.vega.StakingEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.StakingEvent;
  return proto.vega.StakingEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.StakingEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.StakingEvent}
 */
proto.vega.StakingEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBlock(value);
      break;
    case 1001:
      var value = new proto.vega.StakeDeposited;
      reader.readMessage(value,proto.vega.StakeDeposited.deserializeBinaryFromReader);
      msg.setStakeDeposited(value);
      break;
    case 1002:
      var value = new proto.vega.StakeRemoved;
      reader.readMessage(value,proto.vega.StakeRemoved.deserializeBinaryFromReader);
      msg.setStakeRemoved(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.StakingEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.StakingEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.StakingEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakingEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getBlock();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getStakeDeposited();
  if (f != null) {
    writer.writeMessage(
      1001,
      f,
      proto.vega.StakeDeposited.serializeBinaryToWriter
    );
  }
  f = message.getStakeRemoved();
  if (f != null) {
    writer.writeMessage(
      1002,
      f,
      proto.vega.StakeRemoved.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 index = 1;
 * @return {number}
 */
proto.vega.StakingEvent.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.StakingEvent} returns this
 */
proto.vega.StakingEvent.prototype.setIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 block = 2;
 * @return {number}
 */
proto.vega.StakingEvent.prototype.getBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.StakingEvent} returns this
 */
proto.vega.StakingEvent.prototype.setBlock = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional StakeDeposited stake_deposited = 1001;
 * @return {?proto.vega.StakeDeposited}
 */
proto.vega.StakingEvent.prototype.getStakeDeposited = function() {
  return /** @type{?proto.vega.StakeDeposited} */ (
    jspb.Message.getWrapperField(this, proto.vega.StakeDeposited, 1001));
};


/**
 * @param {?proto.vega.StakeDeposited|undefined} value
 * @return {!proto.vega.StakingEvent} returns this
*/
proto.vega.StakingEvent.prototype.setStakeDeposited = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1001, proto.vega.StakingEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.StakingEvent} returns this
 */
proto.vega.StakingEvent.prototype.clearStakeDeposited = function() {
  return this.setStakeDeposited(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.StakingEvent.prototype.hasStakeDeposited = function() {
  return jspb.Message.getField(this, 1001) != null;
};


/**
 * optional StakeRemoved stake_removed = 1002;
 * @return {?proto.vega.StakeRemoved}
 */
proto.vega.StakingEvent.prototype.getStakeRemoved = function() {
  return /** @type{?proto.vega.StakeRemoved} */ (
    jspb.Message.getWrapperField(this, proto.vega.StakeRemoved, 1002));
};


/**
 * @param {?proto.vega.StakeRemoved|undefined} value
 * @return {!proto.vega.StakingEvent} returns this
*/
proto.vega.StakingEvent.prototype.setStakeRemoved = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1002, proto.vega.StakingEvent.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.vega.StakingEvent} returns this
 */
proto.vega.StakingEvent.prototype.clearStakeRemoved = function() {
  return this.setStakeRemoved(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.vega.StakingEvent.prototype.hasStakeRemoved = function() {
  return jspb.Message.getField(this, 1002) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.StakeDeposited.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.StakeDeposited.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.StakeDeposited} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakeDeposited.toObject = function(includeInstance, msg) {
  var f, obj = {
    ethereumAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    vegaPublicKey: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 3, ""),
    blockTime: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.StakeDeposited}
 */
proto.vega.StakeDeposited.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.StakeDeposited;
  return proto.vega.StakeDeposited.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.StakeDeposited} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.StakeDeposited}
 */
proto.vega.StakeDeposited.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setEthereumAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaPublicKey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBlockTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.StakeDeposited.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.StakeDeposited.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.StakeDeposited} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakeDeposited.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEthereumAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getVegaPublicKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getBlockTime();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * optional string ethereum_address = 1;
 * @return {string}
 */
proto.vega.StakeDeposited.prototype.getEthereumAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeDeposited} returns this
 */
proto.vega.StakeDeposited.prototype.setEthereumAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string vega_public_key = 2;
 * @return {string}
 */
proto.vega.StakeDeposited.prototype.getVegaPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeDeposited} returns this
 */
proto.vega.StakeDeposited.prototype.setVegaPublicKey = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string amount = 3;
 * @return {string}
 */
proto.vega.StakeDeposited.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeDeposited} returns this
 */
proto.vega.StakeDeposited.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional int64 block_time = 4;
 * @return {number}
 */
proto.vega.StakeDeposited.prototype.getBlockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.StakeDeposited} returns this
 */
proto.vega.StakeDeposited.prototype.setBlockTime = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.vega.StakeRemoved.prototype.toObject = function(opt_includeInstance) {
  return proto.vega.StakeRemoved.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.vega.StakeRemoved} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakeRemoved.toObject = function(includeInstance, msg) {
  var f, obj = {
    ethereumAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    vegaPublicKey: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 3, ""),
    blockTime: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.vega.StakeRemoved}
 */
proto.vega.StakeRemoved.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.vega.StakeRemoved;
  return proto.vega.StakeRemoved.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.vega.StakeRemoved} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.vega.StakeRemoved}
 */
proto.vega.StakeRemoved.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setEthereumAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setVegaPublicKey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBlockTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.vega.StakeRemoved.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.vega.StakeRemoved.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.vega.StakeRemoved} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.vega.StakeRemoved.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEthereumAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getVegaPublicKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getBlockTime();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * optional string ethereum_address = 1;
 * @return {string}
 */
proto.vega.StakeRemoved.prototype.getEthereumAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeRemoved} returns this
 */
proto.vega.StakeRemoved.prototype.setEthereumAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string vega_public_key = 2;
 * @return {string}
 */
proto.vega.StakeRemoved.prototype.getVegaPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeRemoved} returns this
 */
proto.vega.StakeRemoved.prototype.setVegaPublicKey = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string amount = 3;
 * @return {string}
 */
proto.vega.StakeRemoved.prototype.getAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.vega.StakeRemoved} returns this
 */
proto.vega.StakeRemoved.prototype.setAmount = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional int64 block_time = 4;
 * @return {number}
 */
proto.vega.StakeRemoved.prototype.getBlockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.vega.StakeRemoved} returns this
 */
proto.vega.StakeRemoved.prototype.setBlockTime = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


goog.object.extend(exports, proto.vega);
